// (c) Cartesi and individual authors (see AUTHORS)
// SPDX-License-Identifier: Apache-2.0 (see LICENSE)

pragma solidity ^0.8.8;

import {Test} from "forge-std-1.10.0/src/Test.sol";
import {Vm} from "forge-std-1.10.0/src/Vm.sol";

import {IERC1155Errors} from "@openzeppelin-contracts-5.2.0/interfaces/draft-IERC6093.sol";
import {IERC1155} from "@openzeppelin-contracts-5.2.0/token/ERC1155/IERC1155.sol";
import {IERC20Errors} from "@openzeppelin-contracts-5.2.0/interfaces/draft-IERC6093.sol";
import {IERC20} from "@openzeppelin-contracts-5.2.0/token/ERC20/IERC20.sol";
import {IERC721Errors} from "@openzeppelin-contracts-5.2.0/interfaces/draft-IERC6093.sol";
import {IERC721} from "@openzeppelin-contracts-5.2.0/token/ERC721/IERC721.sol";

import {App} from "src/app/interfaces/App.sol";
import {CanonicalMachine} from "src/common/CanonicalMachine.sol";
import {EpochManager} from "src/app/interfaces/EpochManager.sol";
import {IERC1155BatchPortal} from "src/portals/IERC1155BatchPortal.sol";
import {IERC1155SinglePortal} from "src/portals/IERC1155SinglePortal.sol";
import {IERC20Portal} from "src/portals/IERC20Portal.sol";
import {IERC721Portal} from "src/portals/IERC721Portal.sol";
import {IEtherPortal} from "src/portals/IEtherPortal.sol";
import {ISafeERC20Transfer} from "src/delegatecall/ISafeERC20Transfer.sol";
import {Inbox} from "src/app/interfaces/Inbox.sol";
import {InputEncoding} from "src/common/InputEncoding.sol";
import {Inputs} from "src/common/Inputs.sol";
import {LibBinaryMerkleTree} from "src/library/LibBinaryMerkleTree.sol";
import {LibKeccak256} from "src/library/LibKeccak256.sol";
import {LibOutputValidityProof} from "src/library/LibOutputValidityProof.sol";
import {Outbox} from "src/app/interfaces/Outbox.sol";
import {OutputValidityProof} from "src/common/OutputValidityProof.sol";
import {Outputs} from "src/common/Outputs.sol";

import {LibCannon} from "test/util/LibCannon.sol";
import {LibEmulator} from "test/util/LibEmulator.sol";
import {SimpleBatchERC1155} from "test/util/SimpleERC1155.sol";
import {SimpleERC20} from "test/util/SimpleERC20.sol";
import {SimpleERC721} from "test/util/SimpleERC721.sol";
import {SimpleSingleERC1155} from "test/util/SimpleERC1155.sol";

/// @notice Encodes inputs sent by portals.
/// @dev Necessary for tests because `InputEncoding` only works with values in `calldata`,
/// while some values generated by tests might be in `memory`.
library ExternalInputEncoding {
    function encodeBatchERC1155Deposit(
        IERC1155 token,
        address sender,
        uint256[] calldata tokenIds,
        uint256[] calldata values,
        bytes calldata baseLayerData,
        bytes calldata execLayerData
    ) external pure returns (bytes memory) {
        return InputEncoding.encodeBatchERC1155Deposit(
            token, sender, tokenIds, values, baseLayerData, execLayerData
        );
    }
}

library LibExternalOutputValidityProof {
    function computeOutputsMerkleRoot(OutputValidityProof calldata v, bytes32 outputHash)
        external
        pure
        returns (bytes32)
    {
        return LibOutputValidityProof.computeOutputsMerkleRoot(v, outputHash);
    }
}

library LibExternalBinaryKeccak256MerkleTree {
    function merkleRootAfterReplacement(
        bytes32[] calldata sibs,
        uint256 nodeIndex,
        bytes32 node
    ) external pure returns (bytes32) {
        return LibBinaryMerkleTree.merkleRootAfterReplacement(
            sibs, nodeIndex, node, LibKeccak256.hashPair
        );
    }
}

/// @notice Tests an application contract.
/// @dev Should be inherited for a specific app contract implementation.
abstract contract AppTest is Test {
    using LibCannon for Vm;
    using LibEmulator for LibEmulator.State;
    using LibExternalBinaryKeccak256MerkleTree for bytes32[];
    using LibExternalOutputValidityProof for OutputValidityProof;

    /// @notice A limit on the number of outputs used in fuzzy test cases.
    uint256 constant MAX_FUZZY_OUTPUTS = 32;

    /// @notice An externally-owned account
    address immutable EOA;

    /// @notice A token contract address (to be mocked)
    address immutable TOKEN_MOCK;

    /// @notice The Ether portal
    IEtherPortal immutable ETHER_PORTAL;

    /// @notice The ERC-20 portal
    IERC20Portal immutable ERC20_PORTAL;

    /// @notice The ERC-721 portal
    IERC721Portal immutable ERC721_PORTAL;

    /// @notice The ERC-1155 single portal
    IERC1155SinglePortal immutable ERC1155_SINGLE_PORTAL;

    /// @notice The ERC-1155 batch portal
    IERC1155BatchPortal immutable ERC1155_BATCH_PORTAL;

    /// @notice The safe ERC-20 transfer contract (for DELEGATECALL vouchers).
    ISafeERC20Transfer immutable SAFE_ERC20_TRANSFER;

    /// @notice The application contract used in the tests.
    /// @dev Inheriting contracts should initialize this variable on setup.
    App _app;

    /// @notice The epoch finalizer interface ID used in the tests.
    /// @dev Inheriting contracts should initialize this variable on setup.
    bytes4 _epochFinalizerInterfaceId;

    /// @notice The emulator state, used to add outputs
    /// and generate validity proofs for them.
    LibEmulator.State _emulator;

    // -----------
    // Constructor
    // -----------

    constructor() {
        EOA = _eoaFromString("EOA");
        TOKEN_MOCK = _eoaFromString("TokenMock");
        ETHER_PORTAL = IEtherPortal(vm.getAddress("EtherPortal"));
        ERC20_PORTAL = IERC20Portal(vm.getAddress("ERC20Portal"));
        ERC721_PORTAL = IERC721Portal(vm.getAddress("ERC721Portal"));
        ERC1155_SINGLE_PORTAL = IERC1155SinglePortal(vm.getAddress("ERC1155SinglePortal"));
        ERC1155_BATCH_PORTAL = IERC1155BatchPortal(vm.getAddress("ERC1155BatchPortal"));
        SAFE_ERC20_TRANSFER = ISafeERC20Transfer(vm.getAddress("SafeERC20Transfer"));
    }

    // -----------
    // Inbox tests
    // -----------

    function testInboxInitialState() external view {
        assertEq(_app.getNumberOfInputs(), 0);
        assertEq(_app.getNumberOfInputsBeforeCurrentBlock(), 0);
    }

    /// @notice An inbox action
    /// @param isAddInput Whether the action is to add an input (or, alternatively, to "mine" a block)
    /// @param payload The payload to pass to addInput if isAddInput is `true`
    struct InboxAction {
        bool isAddInput;
        bytes payload;
    }

    function testInboxActions(InboxAction[] calldata actions) external {
        uint256 numberOfInputs;
        uint256 numberOfInputsBeforeCurrentBlock;
        uint256 maxPayloadLength = _computeMaxInputPayloadLength();
        for (uint256 i; i < actions.length; ++i) {
            InboxAction calldata action = actions[i];
            if (action.isAddInput) {
                bytes calldata payload = action.payload;
                if (payload.length <= maxPayloadLength) {
                    uint256 inputIndex = numberOfInputs;
                    _testAddInput(payload, inputIndex);
                    ++numberOfInputs;
                }
            } else {
                _mineBlock();
                numberOfInputsBeforeCurrentBlock = numberOfInputs;
            }
            assertEq(_app.getNumberOfInputs(), numberOfInputs);
            assertEq(
                _app.getNumberOfInputsBeforeCurrentBlock(),
                numberOfInputsBeforeCurrentBlock
            );
        }
    }

    function testAddLargestInput() external {
        uint256 maxPayloadLength = _computeMaxInputPayloadLength();
        bytes memory payload = new bytes(maxPayloadLength);
        _testAddInput(payload, 0);
    }

    function testInputTooLarge() external {
        uint256 maxPayloadLength = _computeMaxInputPayloadLength();
        bytes memory payload = new bytes(maxPayloadLength + 1);
        vm.expectRevert(
            abi.encodeWithSelector(
                Inbox.InputTooLarge.selector,
                _encodeInput(0, address(0), payload).length,
                CanonicalMachine.INPUT_MAX_SIZE
            )
        );
        _app.addInput(payload);
    }

    // ------------------
    // Ether Portal tests
    // ------------------

    function testEtherDepositToEoaReverts(
        address sender,
        uint256 value,
        bytes calldata data
    ) external {
        // First, we bound the value by the current contract balance.
        value = bound(value, 0, address(this).balance);

        // Then, we deal the value to the sender.
        vm.deal(sender, value);

        // And then, we impersonate the sender.
        vm.prank(sender);

        // Depositing Ether in an EOA's account reverts
        // because the call to `addInput` returns nothing,
        // when a `bytes32` value was expected.
        vm.expectRevert();
        ETHER_PORTAL.depositEther{value: value}(App(EOA), data);
    }

    function testEtherDepositToAppSucceeds(
        address sender,
        uint256 value,
        bytes calldata data
    ) external {
        // We need to assume the sender is not the application contract
        // so that our accounting of tokens before and after makes sense.
        // It is also a fair assumption given that an application transfer
        // tokens to itself is a no-op.
        vm.assume(sender != address(_app));

        // First, we bound the value by the current contract balance.
        value = bound(value, 0, address(this).balance);

        // Then, we deal the value to the sender.
        vm.deal(sender, value);

        // We get the number of inputs as the expected input index
        // and also to check that the input count increases by 1.
        uint256 numOfInputsBefore = _app.getNumberOfInputs();

        // We encode the input to check against the InputAdded event to be emitted.
        bytes memory input = _encodeInput(
            numOfInputsBefore,
            address(ETHER_PORTAL),
            InputEncoding.encodeEtherDeposit(sender, value, data)
        );

        uint256 appBalanceBefore = address(_app).balance;

        // And then, we impersonate the sender.
        vm.prank(sender);

        // We make sure an InputAdded event is emitted
        vm.expectEmit(true, false, false, true, address(_app));
        emit Inbox.InputAdded(0, input);

        // Finally, we make the deposit
        ETHER_PORTAL.depositEther{value: value}(_app, data);

        uint256 appBalanceAfter = address(_app).balance;
        uint256 numOfInputsAfter = _app.getNumberOfInputs();

        // Make sure that the app balance has increased by the transfer value
        // and that only one input was added in the deposit tx
        assertEq(appBalanceAfter, appBalanceBefore + value);
        assertEq(numOfInputsAfter, numOfInputsBefore + 1);
    }

    // -------------------
    // ERC-20 Portal tests
    // -------------------

    function testErc20DepositSucceedsWhenTransferFromReturnsTrue(
        address sender,
        uint256 value,
        bytes calldata data
    ) external {
        // First, we encode the `transferFrom` call to be mocked.
        bytes memory transferFrom = _encodeErc20TransferFrom(sender, value);

        // Second, we make the token mock return `true` when
        // called with the expected arguments (`from`, `to`, and `value`).
        vm.mockCall(TOKEN_MOCK, transferFrom, abi.encode(true));

        // We cast the token mock as a ERC-20 token contract
        // to signal that it implements the interface (although partially).
        IERC20 token = IERC20(TOKEN_MOCK);

        // We get the number of inputs as the expected input index
        // and also to check that the input count increases by 1.
        uint256 numOfInputsBefore = _app.getNumberOfInputs();

        // We encode the input to check against the InputAdded event to be emitted.
        bytes memory input = _encodeInput(
            numOfInputsBefore,
            address(ERC20_PORTAL),
            InputEncoding.encodeERC20Deposit(token, sender, value, data)
        );

        // And then, we impersonate the sender.
        vm.prank(sender);

        // We make sure an InputAdded event is emitted.
        vm.expectEmit(true, false, false, true, address(_app));
        emit Inbox.InputAdded(numOfInputsBefore, input);

        // Finally, we make the deposit.
        ERC20_PORTAL.depositERC20Tokens(token, _app, value, data);

        uint256 numOfInputsAfter = _app.getNumberOfInputs();

        // Make sure that the app has received exactly one input.
        assertEq(numOfInputsAfter, numOfInputsBefore + 1);
    }

    function testErc20DepositRevertsWhenTransferFromReturnsFalse(
        address sender,
        uint256 value,
        bytes calldata data
    ) external {
        // First, we encode the `transferFrom` call to be mocked.
        bytes memory transferFrom = _encodeErc20TransferFrom(sender, value);

        // Second, we make the token mock return `false` when
        // called with the expected arguments (`from`, `to`, and `value`).
        vm.mockCall(TOKEN_MOCK, transferFrom, abi.encode(false));

        // We cast the token mock as a ERC-20 token contract
        // to signal that it implements the interface (although partially).
        IERC20 token = IERC20(TOKEN_MOCK);

        // And then, we impersonate the sender.
        vm.prank(sender);

        // Finally, we try to make the deposit, expecting it to revert.
        vm.expectRevert(IERC20Portal.ERC20TransferFailed.selector);
        ERC20_PORTAL.depositERC20Tokens(token, _app, value, data);
    }

    function testErc20DepositRevertsWhenTransferFromReverts(
        address sender,
        uint256 value,
        bytes calldata data,
        bytes calldata errorData
    ) external {
        // First, we encode the `transferFrom` call to be mocked.
        bytes memory transferFrom = _encodeErc20TransferFrom(sender, value);

        // Second, we make the token mock revert when
        // called with the expected arguments (`from`, `to`, and `value`).
        vm.mockCallRevert(TOKEN_MOCK, transferFrom, errorData);

        // We cast the token mock as a ERC-20 token contract
        // to signal that it implements the interface (although partially).
        IERC20 token = IERC20(TOKEN_MOCK);

        // And then, we impersonate the sender.
        vm.prank(sender);

        // Finally, we try to make the deposit, expecting it to revert
        // with the same error raised by `transferFrom`.
        vm.expectRevert(errorData);
        ERC20_PORTAL.depositERC20Tokens(token, _app, value, data);
    }

    function testOpenZeppelinErc20DepositRevertsWhenSenderHasntGivenSufficientAllowance(
        address sender,
        uint256 allowance,
        uint256 value,
        uint256 balance,
        bytes calldata data
    ) external {
        // Assume sender is not the zero address.
        // Otherwise, the token contract raises `ERC20InvalidReceiver`.
        // This is a fair assumption, given that the private key of zero address is unknown.
        vm.assume(sender != address(0));

        // Bound the value, allowance, and balance.
        // We need 0 <= allowance < value <= balance <= type(uint256).max
        allowance = bound(allowance, 0, type(uint256).max - 1);
        value = bound(value, allowance + 1, type(uint256).max);
        balance = bound(balance, value, type(uint256).max);

        // Deploy an OpenZeppelin ERC-20 token contract.
        IERC20 token = _deployOpenZeppelinErc20Token(sender, balance);

        // Give allowance to the ERC-20 portal
        vm.prank(sender);
        token.approve(address(ERC20_PORTAL), allowance);

        // Finally, the sender tries to deposit the tokens.
        // We expect it to fail because the sender has given insufficient allowance to the portal.
        vm.prank(sender);
        vm.expectRevert(_encodeErc20InsufficientAllowance(allowance, value));
        ERC20_PORTAL.depositERC20Tokens(token, _app, value, data);
    }

    function testOpenZeppelinErc20DepositRevertsWhenSenderHasInsufficientBalance(
        address sender,
        uint256 allowance,
        uint256 value,
        uint256 balance,
        bytes calldata data
    ) external {
        // Assume sender is not the zero address.
        // Otherwise, the token contract raises `ERC20InvalidReceiver`.
        // This is a fair assumption, given that the private key of zero address is unknown.
        vm.assume(sender != address(0));

        // Bound the value, allowance, and balance.
        // We need 0 <= balance < value <= allowance <= type(uint256).max
        balance = bound(balance, 0, type(uint256).max - 1);
        value = bound(value, balance + 1, type(uint256).max);
        allowance = bound(allowance, value, type(uint256).max);

        // Deploy an OpenZeppelin ERC-20 token contract.
        IERC20 token = _deployOpenZeppelinErc20Token(sender, balance);

        // Give allowance to the ERC-20 portal
        vm.prank(sender);
        token.approve(address(ERC20_PORTAL), allowance);

        // Finally, the sender tries to deposit the tokens.
        // We expect it to fail because the sender has given insufficient allowance to the portal.
        vm.prank(sender);
        vm.expectRevert(_encodeErc20InsufficientBalance(sender, balance, value));
        ERC20_PORTAL.depositERC20Tokens(token, _app, value, data);
    }

    function testOpenZeppelinErc20DepositSucceeds(
        address sender,
        uint256 value,
        uint256 allowance,
        uint256 balance,
        bytes calldata data
    ) external {
        // We need to assume the sender is not the application contract
        // so that our accounting of tokens before and after makes sense.
        // It is also a fair assumption given that an application transfer
        // tokens to itself is a no-op.
        vm.assume(sender != address(_app));

        // Assume sender is not the zero address.
        // Otherwise, the token contract raises `ERC20InvalidReceiver`.
        // This is a fair assumption, given that the private key of zero address is unknown.
        vm.assume(sender != address(0));

        // Bound the value, allowance, and balance.
        // We need 0 <= value <= allowance, balance <= type(uint256).max
        allowance = bound(allowance, value, type(uint256).max);
        balance = bound(balance, value, type(uint256).max);

        // Deploy an OpenZeppelin ERC-20 token contract.
        IERC20 token = _deployOpenZeppelinErc20Token(sender, balance);

        // Give allowance to the ERC-20 portal
        vm.prank(sender);
        token.approve(address(ERC20_PORTAL), allowance);

        // We get the number of inputs as the expected input index
        // and also to check that the input count increases by 1.
        uint256 numOfInputsBefore = _app.getNumberOfInputs();

        // We encode the input to check against the InputAdded event to be emitted.
        bytes memory input = _encodeInput(
            numOfInputsBefore,
            address(ERC20_PORTAL),
            InputEncoding.encodeERC20Deposit(token, sender, value, data)
        );

        uint256 appBalanceBefore = token.balanceOf(address(_app));

        // And then, we impersonate the sender.
        vm.prank(sender);

        // We make sure an InputAdded event is emitted.
        vm.expectEmit(true, false, false, true, address(_app));
        emit Inbox.InputAdded(numOfInputsBefore, input);

        // Finally, we make the deposit.
        ERC20_PORTAL.depositERC20Tokens(token, _app, value, data);

        uint256 appBalanceAfter = token.balanceOf(address(_app));
        uint256 numOfInputsAfter = _app.getNumberOfInputs();

        // Make sure that the app balance has increased by the transfer value
        // and that only one input was added in the deposit tx
        assertEq(appBalanceAfter, appBalanceBefore + value);
        assertEq(numOfInputsAfter, numOfInputsBefore + 1);
    }

    // --------------------
    // ERC-721 Portal tests
    // --------------------

    function testErc721DepositWhenSafeTransferFromReturns(
        address sender,
        uint256 tokenId,
        bytes calldata baseLayerData,
        bytes calldata execLayerData
    ) external {
        // First, we encode the `safeTransferFrom` call to be mocked.
        bytes memory safeTransferFrom =
            _encodeErc721SafeTransferFrom(sender, address(_app), tokenId, baseLayerData);

        // Second, we make the token mock return when
        // called with the expected arguments (`from`, `to`, `tokenId`, and `data`).
        vm.mockCall(TOKEN_MOCK, safeTransferFrom, abi.encode());

        // We cast the token mock as a ERC-721 token contract
        // to signal that it implements the interface (although partially).
        IERC721 token = IERC721(TOKEN_MOCK);

        // We get the number of inputs as the expected input index
        // and also to check that the input count increases by 1.
        uint256 numOfInputsBefore = _app.getNumberOfInputs();

        // We encode the input to check against the InputAdded event to be emitted.
        bytes memory input = _encodeInput(
            numOfInputsBefore,
            address(ERC721_PORTAL),
            InputEncoding.encodeERC721Deposit(
                token, sender, tokenId, baseLayerData, execLayerData
            )
        );

        // And then, we impersonate the sender.
        vm.prank(sender);

        // We make sure an InputAdded event is emitted.
        vm.expectEmit(true, false, false, true, address(_app));
        emit Inbox.InputAdded(numOfInputsBefore, input);

        // Finally, we make the deposit.
        ERC721_PORTAL.depositERC721Token(
            token, _app, tokenId, baseLayerData, execLayerData
        );

        uint256 numOfInputsAfter = _app.getNumberOfInputs();

        // Make sure that the app has received exactly one input.
        assertEq(numOfInputsAfter, numOfInputsBefore + 1);
    }

    function testErc721DepositWhenSafeTransferFromReverts(
        address sender,
        uint256 tokenId,
        bytes calldata baseLayerData,
        bytes calldata execLayerData,
        bytes calldata errorData
    ) external {
        // First, we encode the `safeTransferFrom` call to be mocked.
        bytes memory safeTransferFrom =
            _encodeErc721SafeTransferFrom(sender, address(_app), tokenId, baseLayerData);

        // Second, we make the token mock return when
        // called with the expected arguments (`from`, `to`, `tokenId`, and `data`).
        vm.mockCallRevert(TOKEN_MOCK, safeTransferFrom, errorData);

        // We cast the token mock as a ERC-721 token contract
        // to signal that it implements the interface (although partially).
        IERC721 token = IERC721(TOKEN_MOCK);

        // And then, we impersonate the sender.
        vm.prank(sender);

        // Finally, we try to make the deposit, expecting it to revert
        // with the same error raised by `safeTransferFrom`.
        vm.expectRevert(errorData);
        ERC721_PORTAL.depositERC721Token(
            token, _app, tokenId, baseLayerData, execLayerData
        );
    }

    function testOpenZeppelinErc721DepositRevertsWhenSenderHasntGivenSufficientApproval(
        address sender,
        uint256 tokenId,
        bytes calldata baseLayerData,
        bytes calldata execLayerData
    ) external {
        // Assume sender is not the zero address.
        // Otherwise, the token contract raises `ERC721InvalidReceiver`.
        // This is a fair assumption, given that the private key of zero address is unknown.
        vm.assume(sender != address(0));

        // Assume sender is an EOA.
        // Otherwise, the token contract raises `ERC721InvalidReceiver`
        // because it probably doesn't implement the interface correctly.
        vm.assume(sender.code.length == 0);

        // Deploy an OpenZeppelin ERC-721 token contract.
        IERC721 token = _deployOpenZeppelinErc721Token(sender, tokenId);

        // Finally, the sender tries to deposit the token.
        // We expect it to fail because the sender hasn't approved the indirect transfer.
        vm.prank(sender);
        vm.expectRevert(
            _encodeErc721InsufficientApproval(address(ERC721_PORTAL), tokenId)
        );
        ERC721_PORTAL.depositERC721Token(
            token, _app, tokenId, baseLayerData, execLayerData
        );
    }

    function testOpenZeppelinErc721DepositRevertsWhenSenderIsNotTokenOwner(
        address sender,
        address owner,
        uint256 tokenId,
        bool setApprovalForAll,
        bytes calldata baseLayerData,
        bytes calldata execLayerData
    ) external {
        // Assume owner is not the zero address.
        // Otherwise, the token contract raises `ERC721InvalidReceiver`.
        // This is a fair assumption, given that the private key of zero address is unknown.
        vm.assume(owner != address(0));

        // Assume sender and owner are different.
        // This ensures that one has the token, but the other doesn't.
        vm.assume(sender != owner);

        // Assume owner is an EOA.
        // Otherwise, the token contract raises `ERC721InvalidReceiver`
        // because it probably doesn't implement the interface correctly.
        vm.assume(owner.code.length == 0);

        // Deploy an OpenZeppelin ERC-721 token contract.
        IERC721 token = _deployOpenZeppelinErc721Token(owner, tokenId);

        vm.prank(owner);
        if (setApprovalForAll) {
            // Make the owner approve any transfer from the portal.
            token.setApprovalForAll(address(ERC721_PORTAL), true);
        } else {
            // Make the owner approve the token transfer from the portal.
            token.approve(address(ERC721_PORTAL), tokenId);
        }

        // Finally, the sender tries to deposit the token it doesn't own.
        // We expect it to fail because the sender doesn't own the token.
        vm.prank(sender);
        vm.expectRevert(_encodeErc721IncorrectOwner(sender, tokenId, owner));
        ERC721_PORTAL.depositERC721Token(
            token, _app, tokenId, baseLayerData, execLayerData
        );
    }

    function testOpenZeppelinErc721DepositRevertsWhenTokenIsNonexistent(
        address sender,
        uint256 tokenId,
        uint256 otherTokenId,
        bytes calldata baseLayerData,
        bytes calldata execLayerData
    ) external {
        // Assume sender is not the zero address.
        // Otherwise, the token contract raises `ERC721InvalidReceiver`.
        // This is a fair assumption, given that the private key of zero address is unknown.
        vm.assume(sender != address(0));

        // Assume sender is an EOA.
        // Otherwise, the token contract raises `ERC721InvalidReceiver`
        // because it probably doesn't implement the interface correctly.
        vm.assume(sender.code.length == 0);

        // We assume the token IDs are different,
        // so that we can mine one and have the other as nonexistent.
        vm.assume(tokenId != otherTokenId);

        // Deploy an OpenZeppelin ERC-721 token contract.
        // We mine a token with ID `otherTokenId` and use `tokenId` for the transfer.
        IERC721 token = _deployOpenZeppelinErc721Token(sender, otherTokenId);

        // Make the sender approve any transfer from the portal.
        // Here, we cannot call `approve` because the token we are going to
        // transfer doesn't exist, so it would raise `ERC721NonexistentToken` here.
        vm.prank(sender);
        token.setApprovalForAll(address(ERC721_PORTAL), true);

        // Finally, the sender tries to deposit a nonexistent token.
        // We expect it to fail because the token doesn't exist.
        vm.prank(sender);
        vm.expectRevert(_encodeErc721NonexistentToken(tokenId));
        ERC721_PORTAL.depositERC721Token(
            token, _app, tokenId, baseLayerData, execLayerData
        );
    }

    function testOpenZeppelinErc721DepositSucceeds(
        address sender,
        uint256 tokenId,
        bool setApprovalForAll,
        bytes calldata baseLayerData,
        bytes calldata execLayerData
    ) external {
        // We need to assume the sender is not the application contract
        // so that our accounting of tokens before and after makes sense.
        // It is also a fair assumption given that an application transfer
        // tokens to itself is a no-op.
        vm.assume(sender != address(_app));

        // Assume sender is not the zero address.
        // Otherwise, the token contract raises `ERC721InvalidReceiver`.
        // This is a fair assumption, given that the private key of zero address is unknown.
        vm.assume(sender != address(0));

        // Assume sender is an EOA.
        // Otherwise, the token contract raises `ERC721InvalidReceiver`
        // because it probably doesn't implement the interface correctly.
        vm.assume(sender.code.length == 0);

        // Deploy an OpenZeppelin ERC-721 token contract.
        IERC721 token = _deployOpenZeppelinErc721Token(sender, tokenId);

        vm.prank(sender);
        if (setApprovalForAll) {
            // Make the sender approve any transfer from the portal.
            token.setApprovalForAll(address(ERC721_PORTAL), true);
        } else {
            // Make the sender approve the token transfer from the portal.
            token.approve(address(ERC721_PORTAL), tokenId);
        }

        // We get the number of inputs as the expected input index
        // and also to check that the input count increases by 1.
        uint256 numOfInputsBefore = _app.getNumberOfInputs();

        // We encode the input to check against the InputAdded event to be emitted.
        bytes memory input = _encodeInput(
            numOfInputsBefore,
            address(ERC721_PORTAL),
            InputEncoding.encodeERC721Deposit(
                token, sender, tokenId, baseLayerData, execLayerData
            )
        );

        uint256 appBalanceBefore = token.balanceOf(address(_app));

        // Prior to the transfer, we make sure the sender owns the token.
        assertEq(token.ownerOf(tokenId), sender);

        // And then, we impersonate the sender.
        vm.prank(sender);

        // We make sure an InputAdded event is emitted.
        vm.expectEmit(true, false, false, true, address(_app));
        emit Inbox.InputAdded(numOfInputsBefore, input);

        // Finally, we make the deposit.
        ERC721_PORTAL.depositERC721Token(
            token, _app, tokenId, baseLayerData, execLayerData
        );

        uint256 appBalanceAfter = token.balanceOf(address(_app));
        uint256 numOfInputsAfter = _app.getNumberOfInputs();

        // Make sure that the app balance has increased by the transfer value
        // and that only one input was added in the deposit tx;
        // We also ensure that the app now owns the token.
        assertEq(appBalanceAfter, appBalanceBefore + 1);
        assertEq(numOfInputsAfter, numOfInputsBefore + 1);
        assertEq(token.ownerOf(tokenId), address(_app));
    }

    // ----------------------------
    // ERC-1155 Single Portal tests
    // ----------------------------

    function testErc1155SingleDepositWhenSafeTransferFromReturns(
        address sender,
        uint256 tokenId,
        uint256 value,
        bytes calldata baseLayerData,
        bytes calldata execLayerData
    ) external {
        // First, we encode the `safeTransferFrom` call to be mocked.
        bytes memory safeTransferFrom = _encodeErc1155SafeTransferFrom(
            sender, address(_app), tokenId, value, baseLayerData
        );

        // Second, we make the token mock return when
        // called with the expected arguments (`from`, `to`, `tokenId`, `value`, and `data`).
        vm.mockCall(TOKEN_MOCK, safeTransferFrom, abi.encode());

        // We cast the token mock as a ERC-1155 token contract
        // to signal that it implements the interface (although partially).
        IERC1155 token = IERC1155(TOKEN_MOCK);

        // We get the number of inputs as the expected input index
        // and also to check that the input count increases by 1.
        uint256 numOfInputsBefore = _app.getNumberOfInputs();

        // We encode the input to check against the InputAdded event to be emitted.
        bytes memory input = _encodeInput(
            numOfInputsBefore,
            address(ERC1155_SINGLE_PORTAL),
            InputEncoding.encodeSingleERC1155Deposit(
                token, sender, tokenId, value, baseLayerData, execLayerData
            )
        );

        // And then, we impersonate the sender.
        vm.prank(sender);

        // We make sure an InputAdded event is emitted.
        vm.expectEmit(true, false, false, true, address(_app));
        emit Inbox.InputAdded(numOfInputsBefore, input);

        // Finally, we make the deposit.
        ERC1155_SINGLE_PORTAL.depositSingleERC1155Token(
            token, _app, tokenId, value, baseLayerData, execLayerData
        );

        uint256 numOfInputsAfter = _app.getNumberOfInputs();

        // Make sure that the app has received exactly one input.
        assertEq(numOfInputsAfter, numOfInputsBefore + 1);
    }

    function testErc1155SingleDepositWhenSafeTransferFromReverts(
        address sender,
        uint256 tokenId,
        uint256 value,
        bytes calldata baseLayerData,
        bytes calldata execLayerData,
        bytes calldata errorData
    ) external {
        // First, we encode the `safeTransferFrom` call to be mocked.
        bytes memory safeTransferFrom = _encodeErc1155SafeTransferFrom(
            sender, address(_app), tokenId, value, baseLayerData
        );

        // Second, we make the token mock return when
        // called with the expected arguments (`from`, `to`, `tokenId`, `value`, and `data`).
        vm.mockCallRevert(TOKEN_MOCK, safeTransferFrom, errorData);

        // We cast the token mock as a ERC-1155 token contract
        // to signal that it implements the interface (although partially).
        IERC1155 token = IERC1155(TOKEN_MOCK);

        // And then, we impersonate the sender.
        vm.prank(sender);

        // Finally, we try to make the deposit, expecting it to revert
        // with the same error raised by `safeTransferFrom`.
        vm.expectRevert(errorData);
        ERC1155_SINGLE_PORTAL.depositSingleERC1155Token(
            token, _app, tokenId, value, baseLayerData, execLayerData
        );
    }

    function testOpenZeppelinErc1155SingleDepositRevertsWhenSenderHasntGivenApprovalForAll(
        address sender,
        uint256 tokenId,
        uint256 value,
        bytes calldata baseLayerData,
        bytes calldata execLayerData
    ) external {
        // Assume sender is not the zero address.
        // Otherwise, the token contract raises `ERC1155InvalidReceiver`.
        // This is a fair assumption, given that the private key of zero address is unknown.
        vm.assume(sender != address(0));

        // Assume sender is an EOA.
        // Otherwise, the token contract raises `ERC1155InvalidReceiver`
        // because it probably doesn't implement the interface correctly.
        vm.assume(sender.code.length == 0);

        // Deploy an OpenZeppelin ERC-1155 token contract.
        IERC1155 token = _deployOpenZeppelinErc1155Token(sender, tokenId, value);

        // Finally, the sender tries to deposit the tokens.
        // We expect it to revert because the sender hasn't given the portal
        // approval for transfering any of its ERC-1155 tokens.
        vm.prank(sender);
        vm.expectRevert(
            _encodeErc1155MissingApprovalForAll(address(ERC1155_SINGLE_PORTAL), sender)
        );
        ERC1155_SINGLE_PORTAL.depositSingleERC1155Token(
            token, _app, tokenId, value, baseLayerData, execLayerData
        );
    }

    function testOpenZeppelinErc1155SingleDepositRevertsWhenSenderHasInsufficientBalance(
        address sender,
        uint256 tokenId,
        uint256 value,
        uint256 balance,
        bytes calldata baseLayerData,
        bytes calldata execLayerData
    ) external {
        // Assume sender is not the zero address.
        // Otherwise, the token contract raises `ERC1155InvalidReceiver`.
        // This is a fair assumption, given that the private key of zero address is unknown.
        vm.assume(sender != address(0));

        // Bound the value and balance.
        // We need 0 <= balance < value <= type(uint256).max
        balance = bound(balance, 0, type(uint256).max - 1);
        value = bound(value, balance + 1, type(uint256).max);

        // Assume sender is an EOA.
        // Otherwise, the token contract raises `ERC1155InvalidReceiver`
        // because it probably doesn't implement the interface correctly.
        vm.assume(sender.code.length == 0);

        // Deploy an OpenZeppelin ERC-1155 token contract.
        IERC1155 token = _deployOpenZeppelinErc1155Token(sender, tokenId, balance);

        // Then, we give the portal approval for handling any tokens on the sender's behalf.
        vm.prank(sender);
        token.setApprovalForAll(address(ERC1155_SINGLE_PORTAL), true);

        // Finally, the sender tries to deposit the tokens.
        // We expect it to revert because the sender doesn't have enough tokens.
        vm.prank(sender);
        vm.expectRevert(
            _encodeErc1155InsufficientBalance(sender, balance, value, tokenId)
        );
        ERC1155_SINGLE_PORTAL.depositSingleERC1155Token(
            token, _app, tokenId, value, baseLayerData, execLayerData
        );
    }

    function testOpenZeppelinErc1155SingleDeposit(
        address sender,
        uint256 tokenId,
        uint256 value,
        bytes calldata baseLayerData,
        bytes calldata execLayerData
    ) external {
        // Assume sender is not the zero address.
        // Otherwise, the token contract raises `ERC1155InvalidReceiver`.
        // This is a fair assumption, given that the private key of zero address is unknown.
        vm.assume(sender != address(0));

        // Assume sender is an EOA.
        // Otherwise, the token contract raises `ERC1155InvalidReceiver`
        // because it probably doesn't implement the interface correctly.
        vm.assume(sender.code.length == 0);

        // Deploy an OpenZeppelin ERC-1155 token contract.
        IERC1155 token = _deployOpenZeppelinErc1155Token(sender, tokenId, value);

        // Then, we give the portal approval for handling any tokens on the sender's behalf.
        vm.prank(sender);
        token.setApprovalForAll(address(ERC1155_SINGLE_PORTAL), true);

        // Finally, the sender tries to deposit the tokens.
        vm.prank(sender);
        ERC1155_SINGLE_PORTAL.depositSingleERC1155Token(
            token, _app, tokenId, value, baseLayerData, execLayerData
        );
    }

    function testOpenZeppelinErc1155SingleDepositSucceeds(
        address sender,
        uint256 tokenId,
        uint256 value,
        bytes calldata baseLayerData,
        bytes calldata execLayerData
    ) external {
        // Assume sender is not the zero address.
        // Otherwise, the token contract raises `ERC1155InvalidReceiver`.
        // This is a fair assumption, given that the private key of zero address is unknown.
        vm.assume(sender != address(0));

        // Assume sender is an EOA.
        // Otherwise, the token contract raises `ERC1155InvalidReceiver`
        // because it probably doesn't implement the interface correctly.
        vm.assume(sender.code.length == 0);

        // Deploy an OpenZeppelin ERC-1155 token contract.
        IERC1155 token = _deployOpenZeppelinErc1155Token(sender, tokenId, value);

        // Then, we give the portal approval for handling any tokens on the sender's behalf.
        vm.prank(sender);
        token.setApprovalForAll(address(ERC1155_SINGLE_PORTAL), true);

        // We get the number of inputs as the expected input index
        // and also to check that the input count increases by 1.
        uint256 numOfInputsBefore = _app.getNumberOfInputs();

        // We encode the input to check against the InputAdded event to be emitted.
        bytes memory input = _encodeInput(
            numOfInputsBefore,
            address(ERC1155_SINGLE_PORTAL),
            InputEncoding.encodeSingleERC1155Deposit(
                token, sender, tokenId, value, baseLayerData, execLayerData
            )
        );

        uint256 appBalanceBefore = token.balanceOf(address(_app), tokenId);

        // We make sure an InputAdded event is emitted.
        vm.expectEmit(true, false, false, true, address(_app));
        emit Inbox.InputAdded(numOfInputsBefore, input);

        // Finally, the sender tries to deposit the tokens.
        vm.prank(sender);
        ERC1155_SINGLE_PORTAL.depositSingleERC1155Token(
            token, _app, tokenId, value, baseLayerData, execLayerData
        );

        uint256 appBalanceAfter = token.balanceOf(address(_app), tokenId);
        uint256 numOfInputsAfter = _app.getNumberOfInputs();

        // Make sure that the app balance has increased by the transfer value
        // and that only one input was added in the deposit tx
        assertEq(appBalanceAfter, appBalanceBefore + value);
        assertEq(numOfInputsAfter, numOfInputsBefore + 1);
    }

    // ---------------------------
    // ERC-1155 Batch Portal tests
    // ---------------------------

    function testErc1155BatchDepositWhenSafeBatchTransferFromReturns(
        address sender,
        uint256[] calldata tokenIds,
        uint256[] calldata values,
        bytes calldata baseLayerData,
        bytes calldata execLayerData
    ) external {
        // First, we encode the `safeBatchTransferFrom` call to be mocked.
        bytes memory safeBatchTransferFrom = _encodeErc1155SafeBatchTransferFrom(
            sender, address(_app), tokenIds, values, baseLayerData
        );

        // Second, we make the token mock return when
        // called with the expected arguments (`from`, `to`, `tokenIds`, `values`, and `data`).
        vm.mockCall(TOKEN_MOCK, safeBatchTransferFrom, abi.encode());

        // We cast the token mock as a ERC-1155 token contract
        // to signal that it implements the interface (although partially).
        IERC1155 token = IERC1155(TOKEN_MOCK);

        // We get the number of inputs as the expected input index
        // and also to check that the input count increases by 1.
        uint256 numOfInputsBefore = _app.getNumberOfInputs();

        // We encode the input to check against the InputAdded event to be emitted.
        bytes memory input = _encodeInput(
            numOfInputsBefore,
            address(ERC1155_BATCH_PORTAL),
            InputEncoding.encodeBatchERC1155Deposit(
                token, sender, tokenIds, values, baseLayerData, execLayerData
            )
        );

        // And then, we impersonate the sender.
        vm.prank(sender);

        // We make sure an InputAdded event is emitted.
        vm.expectEmit(true, false, false, true, address(_app));
        emit Inbox.InputAdded(numOfInputsBefore, input);

        // Finally, we make the deposit.
        ERC1155_BATCH_PORTAL.depositBatchERC1155Token(
            token, _app, tokenIds, values, baseLayerData, execLayerData
        );

        uint256 numOfInputsAfter = _app.getNumberOfInputs();

        // Make sure that the app has received exactly one input.
        assertEq(numOfInputsAfter, numOfInputsBefore + 1);
    }

    function testErc1155BatchDepositWhenSafeBatchTransferFromReverts(
        address sender,
        uint256[] calldata tokenIds,
        uint256[] calldata values,
        bytes calldata baseLayerData,
        bytes calldata execLayerData,
        bytes calldata errorData
    ) external {
        // First, we encode the `safeBatchTransferFrom` call to be mocked.
        bytes memory safeBatchTransferFrom = _encodeErc1155SafeBatchTransferFrom(
            sender, address(_app), tokenIds, values, baseLayerData
        );

        // Second, we make the token mock return when
        // called with the expected arguments (`from`, `to`, `tokenIds`, `values`, and `data`).
        vm.mockCallRevert(TOKEN_MOCK, safeBatchTransferFrom, errorData);

        // We cast the token mock as a ERC-1155 token contract
        // to signal that it implements the interface (although partially).
        IERC1155 token = IERC1155(TOKEN_MOCK);

        // And then, we impersonate the sender.
        vm.prank(sender);

        // Finally, we try to make the deposit, expecting it to revert
        // with the same error raised by `safeTransferFrom`.
        vm.expectRevert(errorData);
        ERC1155_BATCH_PORTAL.depositBatchERC1155Token(
            token, _app, tokenIds, values, baseLayerData, execLayerData
        );
    }

    function testOpenZeppelinErc1155BatchDepositRevertsWhenArrayLengthsMismatch(
        address sender,
        bytes32 tokenIdSeed,
        uint256[] calldata balances,
        uint256[] calldata values,
        bytes calldata baseLayerData,
        bytes calldata execLayerData
    ) external {
        // Assume sender is not the zero address.
        // Otherwise, the token contract raises `ERC1155InvalidReceiver`.
        // This is a fair assumption, given that the private key of zero address is unknown.
        vm.assume(sender != address(0));

        // Assume sender is an EOA.
        // Otherwise, the token contract raises `ERC1155InvalidReceiver`
        // because it probably doesn't implement the interface correctly.
        vm.assume(sender.code.length == 0);

        // Generate an array of token IDs.
        uint256[] memory tokenIds = _generateTokenIds(balances, tokenIdSeed);

        // Assume the length of the arrays are different
        vm.assume(tokenIds.length != values.length);

        // Deploy an OpenZeppelin ERC-1155 token contract.
        IERC1155 token = _deployOpenZeppelinErc1155Token(sender, tokenIds, balances);

        // Then, we give the portal approval for handling any tokens on the sender's behalf.
        vm.prank(sender);
        token.setApprovalForAll(address(ERC1155_BATCH_PORTAL), true);

        // Finally, the sender tries to deposit the tokens.
        // We expect it to revert because the array lengths are different.
        vm.prank(sender);
        vm.expectRevert(_encodeErc1155InvalidArrayLength(tokenIds.length, values.length));
        ERC1155_BATCH_PORTAL.depositBatchERC1155Token(
            token, _app, tokenIds, values, baseLayerData, execLayerData
        );
    }

    function testOpenZeppelinErc1155BatchDepositRevertsWhenSenderHasntGivenApprovalForAll(
        address sender,
        bytes32 tokenIdSeed,
        uint256[] calldata balances,
        bytes calldata baseLayerData,
        bytes calldata execLayerData
    ) external {
        // Assume sender is not the zero address.
        // Otherwise, the token contract raises `ERC1155InvalidReceiver`.
        // This is a fair assumption, given that the private key of zero address is unknown.
        vm.assume(sender != address(0));

        // Assume sender is an EOA.
        // Otherwise, the token contract raises `ERC1155InvalidReceiver`
        // because it probably doesn't implement the interface correctly.
        vm.assume(sender.code.length == 0);

        // Generate an array of token IDs and values.
        uint256[] memory tokenIds = _generateTokenIds(balances, tokenIdSeed);
        uint256[] memory values = _generateTokenValues(balances);

        // Deploy an OpenZeppelin ERC-1155 token contract.
        IERC1155 token = _deployOpenZeppelinErc1155Token(sender, tokenIds, balances);

        // Finally, the sender tries to deposit the tokens.
        // We expect it to revert because the sender hasn't given the portal
        // approval for transfering any of its ERC-1155 tokens.
        vm.prank(sender);
        vm.expectRevert(
            _encodeErc1155MissingApprovalForAll(address(ERC1155_BATCH_PORTAL), sender)
        );
        ERC1155_BATCH_PORTAL.depositBatchERC1155Token(
            token, _app, tokenIds, values, baseLayerData, execLayerData
        );
    }

    function testOpenZeppelinErc1155BatchDepositSucceeds(
        address sender,
        bytes32 tokenIdSeed,
        uint256[] calldata balances,
        bytes calldata baseLayerData,
        bytes calldata execLayerData
    ) external {
        // Assume sender is not the zero address.
        // Otherwise, the token contract raises `ERC1155InvalidReceiver`.
        // This is a fair assumption, given that the private key of zero address is unknown.
        vm.assume(sender != address(0));

        // Assume sender is an EOA.
        // Otherwise, the token contract raises `ERC1155InvalidReceiver`
        // because it probably doesn't implement the interface correctly.
        vm.assume(sender.code.length == 0);

        // Generate an array of token IDs and values.
        uint256[] memory tokenIds = _generateTokenIds(balances, tokenIdSeed);
        uint256[] memory values = _generateTokenValues(balances);

        // Deploy an OpenZeppelin ERC-1155 token contract.
        IERC1155 token = _deployOpenZeppelinErc1155Token(sender, tokenIds, balances);

        // Then, we give the portal approval for handling any tokens on the sender's behalf.
        vm.prank(sender);
        token.setApprovalForAll(address(ERC1155_BATCH_PORTAL), true);

        // We get the number of inputs as the expected input index
        // and also to check that the input count increases by 1.
        uint256 numOfInputsBefore = _app.getNumberOfInputs();

        // We encode the input to check against the InputAdded event to be emitted.
        bytes memory input = _encodeInput(
            numOfInputsBefore,
            address(ERC1155_BATCH_PORTAL),
            ExternalInputEncoding.encodeBatchERC1155Deposit(
                token, sender, tokenIds, values, baseLayerData, execLayerData
            )
        );

        // Create an array with just the app address so that we can query the
        // app contract balance for each token in a single batch call.
        address[] memory appAddresses = _repeat(address(_app), tokenIds.length);
        uint256[] memory appBalancesBefore = token.balanceOfBatch(appAddresses, tokenIds);

        // We make sure an InputAdded event is emitted.
        vm.expectEmit(true, false, false, true, address(_app));
        emit Inbox.InputAdded(numOfInputsBefore, input);

        // Finally, the sender deposits the tokens.
        vm.prank(sender);
        ERC1155_BATCH_PORTAL.depositBatchERC1155Token(
            token, _app, tokenIds, values, baseLayerData, execLayerData
        );

        // Make sure that the app balance has increased by the transfer value
        uint256[] memory appBalancesAfter = token.balanceOfBatch(appAddresses, tokenIds);
        assertEq(appBalancesAfter.length, appBalancesBefore.length);
        for (uint256 i; i < appBalancesAfter.length; ++i) {
            assertEq(appBalancesAfter[i], appBalancesBefore[i] + values[i]);
        }

        // Make sure that only one input was added in the deposit tx
        uint256 numOfInputsAfter = _app.getNumberOfInputs();
        assertEq(numOfInputsAfter, numOfInputsBefore + 1);
    }

    // -------------------
    // Epoch manager tests
    // -------------------

    function testGetEpochFinalizerInterfaceId() external view {
        assertEq(_app.getEpochFinalizerInterfaceId(), _epochFinalizerInterfaceId);
    }

    function testGetFinalizedEpochCount() external view {
        assertEq(_app.getFinalizedEpochCount(), 0);
    }

    function testCloseAndFinalizeEpoch(bytes32[3] calldata postEpochOutputsRoots)
        external
    {
        for (uint256 epochIndex; epochIndex < postEpochOutputsRoots.length; ++epochIndex)
        {
            // Initially, the epoch is open and empty.

            vm.expectRevert(_encodeCannotCloseEmptyEpoch(epochIndex));
            _app.canEpochBeClosed(epochIndex);

            vm.expectRevert(_encodeCannotCloseEmptyEpoch(epochIndex));
            _app.closeEpoch(epochIndex);

            // Right after adding an input, the epoch is still empty.

            _addEmptyInput();

            vm.expectRevert(_encodeCannotCloseEmptyEpoch(epochIndex));
            _app.canEpochBeClosed(epochIndex);

            vm.expectRevert(_encodeCannotCloseEmptyEpoch(epochIndex));
            _app.closeEpoch(epochIndex);

            // We need to "mine" a block for the input to be included in the epoch.

            _mineBlock();

            // This call should not revert, signaling that the epoch can be closed.

            _app.canEpochBeClosed(epochIndex);

            // Close the epoch and get the epoch finalizer.

            address epochFinalizer = _closeEpoch(epochIndex);

            // Generate the post-epoch state root

            bytes32[] memory proof;
            bytes32 postEpochStateRoot;
            bytes32 postEpochOutputsRoot;

            proof = _randomOutputsRootProof();
            postEpochOutputsRoot = postEpochOutputsRoots[epochIndex];
            postEpochStateRoot = _computePostEpochStateRoot(proof, postEpochOutputsRoot);

            vm.expectRevert(_encodeInvalidPostEpochState(epochIndex, postEpochStateRoot));
            _app.canEpochBeFinalized(epochIndex, postEpochOutputsRoot, proof);

            _preFinalizeEpoch(epochIndex, epochFinalizer, postEpochStateRoot);

            // This call should not revert, signaling that the epoch can be finalized.

            _app.canEpochBeFinalized(epochIndex, postEpochOutputsRoot, proof);

            _app.finalizeEpoch(epochIndex, postEpochOutputsRoot, proof);

            assertEq(_app.getFinalizedEpochCount(), 1 + epochIndex);
            assertTrue(_app.isOutputsRootFinal(postEpochOutputsRoot));
        }
    }

    // ------------
    // Outbox tests
    // ------------

    function testGetNumberOfExecutedOutputs() external view {
        assertEq(_app.getNumberOfExecutedOutputs(), 0);
    }

    function testWasOutputExecuted(uint256 outputIndex) external view {
        assertFalse(_app.wasOutputExecuted(outputIndex));
    }

    function testValidateOutputHashWithInvalidOutputsMerkleRoot(bytes32 outputHash)
        external
    {
        // Generate a random outputs validity proof and compute the outputs root
        OutputValidityProof memory proof = _randomOutputValidityProof();
        bytes32 outputsRoot = proof.computeOutputsMerkleRoot(outputHash);

        // Validating the output hash should fail
        vm.expectRevert(_encodeInvalidOutputsMerkleRoot(outputsRoot));
        _app.validateOutputHash(outputHash, proof);
    }

    function testValidateOrExecuteOutputWithInvalidOutputsMerkleRoot(
        bytes calldata output
    ) external {
        // Generate a random outputs validity proof and compute the outputs root
        OutputValidityProof memory proof = _randomOutputValidityProof();
        bytes32 outputsRoot = proof.computeOutputsMerkleRoot(keccak256(output));

        // Validating the output should fail
        vm.expectRevert(_encodeInvalidOutputsMerkleRoot(outputsRoot));
        _app.validateOutput(output, proof);

        // Executing the output should fail
        vm.expectRevert(_encodeInvalidOutputsMerkleRoot(outputsRoot));
        _app.executeOutput(output, proof);
    }

    function testOutboxWithInvalidOutputHashesSiblingsArrayLength(
        bytes32 outputHash,
        bytes calldata output,
        bytes32[] calldata outputHashesSiblings
    ) external {
        // Use an array of siblings with invalid length to construct
        // an output validity proof with a random output index
        vm.assume(outputHashesSiblings.length != CanonicalMachine.LOG2_MAX_OUTPUTS);
        OutputValidityProof memory proof = OutputValidityProof({
            outputIndex: _randomOutputIndex(),
            outputHashesSiblings: outputHashesSiblings
        });

        // Validating the output hash should fail
        vm.expectRevert(Outbox.InvalidOutputHashesSiblingsArrayLength.selector);
        _app.validateOutputHash(outputHash, proof);

        // Validating the output should fail
        vm.expectRevert(Outbox.InvalidOutputHashesSiblingsArrayLength.selector);
        _app.validateOutput(output, proof);

        // Executing the output should fail
        vm.expectRevert(Outbox.InvalidOutputHashesSiblingsArrayLength.selector);
        _app.executeOutput(output, proof);
    }

    function testValidateOutputAndOutputHash(bytes[] calldata outputs) external {
        // We limit the number of outputs as not to slow down the tests too much.
        vm.assume(outputs.length <= MAX_FUZZY_OUTPUTS);

        // We add all outputs to the emulator state.
        _addOutputs(outputs);

        // We finalize the current epoch with a post-epoch outputs root that allows
        // the validation of the outputs provided.
        _makeOutputsValid();

        // Finally, we validate each output and their hashes
        for (uint64 i; i < outputs.length; ++i) {
            OutputValidityProof memory proof = _getOutputValidityProof(i);
            _app.validateOutputHash(keccak256(outputs[i]), proof);
            _app.validateOutput(outputs[i], proof);
        }
    }

    uint256 constant NOTICE = uint256(keccak256("notice"));
    uint256 constant CALL_VOUCHER = uint256(keccak256("call voucher"));
    uint256 constant DELEGATECALL_VOUCHER = uint256(keccak256("delegatecall voucher"));

    struct TypedOutput {
        uint256 kind;
        address destination; // if `kind` is `CALL_VOUCHER` or `DELEGATECALL_VOUCHER`
        uint256 value; // if `kind` is `CALL_VOUCHER`
        bytes payload;
    }

    function testTypedOutputs(uint256 outputCount) external {
        // We bound the number of outputs so that the test doesn't take too long.
        outputCount = bound(outputCount, 0, MAX_FUZZY_OUTPUTS);

        // We allocate an array of typed outputs (as structured data)
        // and an array of outputs (as encoded byte arrays)
        TypedOutput[] memory typedOutputs = new TypedOutput[](outputCount);
        bytes[] memory outputs = new bytes[](outputCount);

        // We also keep a counter for the required balance of the application
        // contract for all the call vouchers that carry Ether
        uint256 requiredBalance;

        // Populate the array of outputs with random data.
        for (uint256 i; i < outputs.length; ++i) {
            // We choose the output kind.
            uint256 kind = _randomTypedOutputKind();

            // We pick a random EOA address as the destination so that
            // we don't accidentally call an existing contract.
            address destination = _randomEoaAddress();

            // We pick a random value that still gives the application contract
            // enough balance to execute all vouchers (limited by the max uint256 value).
            uint256 value = vm.randomUint(0, type(uint256).max - requiredBalance);

            /// We pick a random payload that is not too long.
            bytes memory payload = vm.randomBytes(vm.randomUint(0, 1024));

            // We structure and encode the typed output
            typedOutputs[i] = TypedOutput(kind, destination, value, payload);
            outputs[i] = _encodeTypedOutput(typedOutputs[i]);

            // We increment the required balance counter
            requiredBalance += value;
        }

        // We add all outputs to the emulator state.
        // We shuffle the output indices to make the order of execution random
        uint64[] memory outputIndices = _shuffle(_addOutputs(outputs));

        // We finalize the current epoch with a post-epoch outputs root that allows
        // the validation of the outputs provided.
        _makeOutputsValid();

        // First, we try to execute the vouchers with more value than the app contract
        // balance to ensure it raises the `InsufficientFunds` error.
        for (uint64 i; i < outputIndices.length; ++i) {
            // Retrieve the output index, the output, the proof, and typed output struct
            uint64 outputIndex = uint64(outputIndices[i]);
            bytes memory output = outputs[outputIndex];
            OutputValidityProof memory proof = _getOutputValidityProof(outputIndex);
            TypedOutput memory typedOutput = typedOutputs[outputIndex];

            // We can validate these outputs regardless of there being
            // enough Ether to execute them or not.
            _app.validateOutput(output, proof);
            _app.validateOutputHash(keccak256(output), proof);

            uint256 value = typedOutput.value;
            uint256 balance = address(_app).balance;

            // Then we filter only the vouchers with more value than the app contract balance
            if (typedOutput.kind == CALL_VOUCHER && value > balance) {
                // Trying to execute the output reverts with an `InsufficientFunds` error
                // with the voucher value and the app contract balance as arguments.
                vm.expectRevert(_encodeInsufficientFunds(value, balance));
                _app.executeOutput(output, proof);
            }
        }

        // We give the app enough balance to execute all vouchers
        vm.deal(address(_app), requiredBalance);

        // Finally, we validate/execute the typed outputs in a random order
        for (uint64 i; i < outputIndices.length; ++i) {
            // Retrieve the output index, the output, the proof, and typed output struct
            uint64 outputIndex = uint64(outputIndices[i]);
            bytes memory output = outputs[outputIndex];
            OutputValidityProof memory proof = _getOutputValidityProof(outputIndex);
            TypedOutput memory typedOutput = typedOutputs[outputIndex];

            // We can validate the output and its hash beforehand.
            _app.validateOutput(output, proof);
            _app.validateOutputHash(keccak256(output), proof);

            // If the typed output is executable, execute it.
            if (_isTypedOutputExecutable(typedOutput)) {
                // Get the number of executed output before calling `executeOutput`.
                // This will be used to check later whether this number was incremented by 1.
                uint256 numOfExecutedOutputs = _app.getNumberOfExecutedOutputs();

                // Make sure the output was not executed yet.
                assertFalse(_app.wasOutputExecuted(outputIndex));

                // Expect the destination to be called once with the given value and payload
                if (typedOutput.kind == DELEGATECALL_VOUCHER) {
                    address destination = typedOutput.destination;
                    bytes memory payload = typedOutput.payload;
                    // We don't pass a value here, otherwise Forge will expect a CALL to occurr,
                    // but actually it is a DELEGATECALL that occurrs.
                    vm.expectCall(destination, payload, 1);
                } else if (typedOutput.kind == CALL_VOUCHER) {
                    address destination = typedOutput.destination;
                    uint256 value = typedOutput.value;
                    bytes memory payload = typedOutput.payload;
                    vm.expectCall(destination, value, payload, 1);
                }

                // Expect an `OutputExecuted` event to be emitted with the right index and output args
                vm.expectEmit(false, false, false, true, address(_app));
                emit Outbox.OutputExecuted(outputIndex, output);

                // Finally, call `executeOutput`.
                _app.executeOutput(output, proof);

                // Check whether the output was marked as executed.
                assertTrue(_app.wasOutputExecuted(outputIndex));

                // Check whether the number of executed outputs was incremented by 1.
                assertEq(_app.getNumberOfExecutedOutputs(), numOfExecutedOutputs + 1);

                // Trying to execute the output again reverts.
                vm.expectRevert(_encodeOutputNotReexecutable(output));
                _app.executeOutput(output, proof);

                // We can still validate the output and its hash afterhand.
                _app.validateOutput(output, proof);
                _app.validateOutputHash(keccak256(output), proof);
            } else {
                // If, otherwise, the typed output is not executable,
                // then trying to execute the output will fail.
                vm.expectRevert(_encodeOutputNotExecutable(output));
                _app.executeOutput(output, proof);
            }
        }
    }

    function testEtherWithdrawal(uint256 value, uint256 supply, bytes calldata payload)
        external
    {
        // Bound the Ether supply.
        // We need 0 <= value <= supply <= type(uint256).max
        supply = bound(supply, value, type(uint256).max);

        // Generate a random EOA address to be the voucher destination.
        // This avoids vouchers to existing contracts that might revert.
        address destination = _randomEoaAddress();

        // We encode the call voucher directly
        bytes memory output = _encodeCallVoucher(destination, value, payload);

        // We then add the output to the emulator state.
        uint64 outputIndex = _addOutput(output);

        // We make the output valid and ready for execution
        _makeOutputsValid();

        // Get the output validity proof ready
        OutputValidityProof memory proof = _getOutputValidityProof(outputIndex);

        // Get the app contract balance to check whether
        // we need to deal it some Ether before executing the voucher.
        uint256 balance = address(_app).balance;

        if (value > balance) {
            // If value is greater than the app contract balance,
            // then executing the voucher right away will fail
            // with an `InsufficientFunds` error.
            vm.expectRevert(_encodeInsufficientFunds(value, balance));
            _app.executeOutput(output, proof);
        }

        // In order to successfully execute the voucher,
        // we need to deal the app contract some Ether.
        vm.deal(address(_app), supply);

        // Get the app contract balance before the withdrawal.
        uint256 appBalanceBefore = address(_app).balance;

        // We get the balance of the destination before the withdrawal.
        uint256 destBalanceBefore = destination.balance;

        // Finally, we execute the output
        _executeOutput(output, proof);

        // Get the app contract balance after the withdrawal.
        uint256 appBalanceAfter = address(_app).balance;

        // We get the balance of the destination after the withdrawal.
        uint256 destBalanceAfter = destination.balance;

        // Make sure the value has moved from the app contract
        // to the destination account.
        assertEq(destBalanceAfter, destBalanceBefore + value);
        assertEq(appBalanceAfter, appBalanceBefore - value);
    }

    function testOpenZeppelinErc20Withdrawal(uint256 supply, uint256 value, bool safe)
        external
    {
        // Bound the token supply.
        // We need 0 <= value <= supply <= type(uint256).max
        supply = bound(supply, value, type(uint256).max);

        // Generate an EOA address for the token owner and token recipient
        // This avoids undesired side effects if the address is zero
        // or if it points to an existing contract.
        address tokenOwner = _randomEoaAddress();
        address destination = _randomEoaAddress();

        // Deploy an OpenZeppelin ERC-20 token contract.
        IERC20 token = _deployOpenZeppelinErc20Token(tokenOwner, supply);

        // We encode the voucher differently depending on the value of the `safe` parameter
        // If `safe` is `true`, encode a DELEGATECALL voucher to the SafeERC20Transfer contract.
        // Otherwise, encode a regular CALL voucher to the token contract itself.
        bytes memory output = safe
            ? _encodeDelegateCallVoucher(
                address(SAFE_ERC20_TRANSFER),
                _encodeErc20SafeTransfer(token, destination, value)
            )
            : _encodeCallVoucher(address(token), 0, _encodeErc20Transfer(destination, value));

        // We then add the output to the emulator state.
        uint64 outputIndex = _addOutput(output);

        // We make the output valid and ready for execution
        _makeOutputsValid();

        // Get the output validity proof ready
        OutputValidityProof memory proof = _getOutputValidityProof(outputIndex);

        // Get the app contract token balance to check whether
        // we need to deal it some tokens before executing the voucher.
        uint256 balance = token.balanceOf(address(_app));

        if (value > balance) {
            // If value is greater than the app contract balance,
            // then executing the voucher right away will fail
            // with an `ERC20InsufficientBalance` error.
            vm.expectRevert(
                _encodeErc20InsufficientBalance(address(_app), balance, value)
            );
            _app.executeOutput(output, proof);
        }

        // In order to successfully execute the voucher,
        // we need to deal the app contract some tokens.
        vm.prank(tokenOwner);
        token.transfer(address(_app), supply);

        // Get the app contract balance before the withdrawal.
        uint256 appBalanceBefore = token.balanceOf(address(_app));

        // We get the balance of the destination before the withdrawal.
        uint256 destBalanceBefore = token.balanceOf(destination);

        // Finally, we execute the output
        _executeOutput(output, proof);

        // Get the app contract balance after the withdrawal.
        uint256 appBalanceAfter = token.balanceOf(address(_app));

        // We get the balance of the destination after the withdrawal.
        uint256 destBalanceAfter = token.balanceOf(destination);

        // Make sure the value has moved from the app contract
        // to the destination account.
        assertEq(destBalanceAfter, destBalanceBefore + value);
        assertEq(appBalanceAfter, appBalanceBefore - value);
    }

    function testOpenZeppelinErc721Withdrawal(uint256 tokenId, bytes calldata data)
        external
    {
        // Generate an EOA address for the token owner and token recipient
        // This avoids undesired side effects if the address is zero
        // or if it points to an existing contract.
        address tokenOwner = _randomEoaAddress();
        address destination = _randomEoaAddress();

        // Deploy an OpenZeppelin ERC-721 token contract.
        IERC721 token = _deployOpenZeppelinErc721Token(tokenOwner, tokenId);

        // We encode the call voucher directly
        bytes memory output = _encodeCallVoucher(
            address(token),
            0,
            _encodeErc721SafeTransferFrom(address(_app), destination, tokenId, data)
        );

        // We then add the output to the emulator state.
        uint64 outputIndex = _addOutput(output);

        // We make the output valid and ready for execution
        _makeOutputsValid();

        // Get the output validity proof ready
        OutputValidityProof memory proof = _getOutputValidityProof(outputIndex);

        // If the app contract balance doesn't own the token,
        // then executing the voucher right away will fail
        // with an `ERC721InsufficientApproval` error.
        vm.expectRevert(_encodeErc721InsufficientApproval(address(_app), tokenId));
        _app.executeOutput(output, proof);

        // In order to successfully execute the voucher,
        // we need to transfer the token to the app contract.
        vm.prank(tokenOwner);
        token.safeTransferFrom(tokenOwner, address(_app), tokenId);

        // Make sure the token is owned by the app contract before.
        assertEq(token.ownerOf(tokenId), address(_app));

        // Get the app contract balance before the withdrawal.
        uint256 appBalanceBefore = token.balanceOf(address(_app));

        // We get the balance of the destination before the withdrawal.
        uint256 destBalanceBefore = token.balanceOf(destination);

        // Finally, we execute the output
        _executeOutput(output, proof);

        // Get the app contract balance after the withdrawal.
        uint256 appBalanceAfter = token.balanceOf(address(_app));

        // We get the balance of the destination after the withdrawal.
        uint256 destBalanceAfter = token.balanceOf(destination);

        // Make sure the token has moved from the app contract
        // to the destination account.
        assertEq(token.ownerOf(tokenId), destination);
        assertEq(destBalanceAfter, destBalanceBefore + 1);
        assertEq(appBalanceAfter, appBalanceBefore - 1);
    }

    function testOpenZeppelinErc1155SingleWithdrawal(
        uint256 tokenId,
        uint256 value,
        uint256 supply,
        bytes calldata data
    ) external {
        // Bound the token supply.
        // We need 0 <= value <= supply <= type(uint256).max
        supply = bound(supply, value, type(uint256).max);

        // Generate an EOA address for the token owner and token recipient
        // This avoids undesired side effects if the address is zero
        // or if it points to an existing contract.
        address tokenOwner = _randomEoaAddress();
        address destination = _randomEoaAddress();

        // Deploy an OpenZeppelin ERC-1155 token contract.
        IERC1155 token = _deployOpenZeppelinErc1155Token(tokenOwner, tokenId, supply);

        // We encode the call voucher directly
        bytes memory output = _encodeCallVoucher(
            address(token),
            0,
            _encodeErc1155SafeTransferFrom(
                address(_app), destination, tokenId, value, data
            )
        );

        // We then add the output to the emulator state.
        uint64 outputIndex = _addOutput(output);

        // We make the output valid and ready for execution
        _makeOutputsValid();

        // Get the output validity proof ready
        OutputValidityProof memory proof = _getOutputValidityProof(outputIndex);

        // Get the app contract token balance to check whether
        // we need to deal it some tokens before executing the voucher.
        uint256 balance = token.balanceOf(address(_app), tokenId);

        if (value > balance) {
            // If value is greater than the app contract balance,
            // then executing the voucher right away will fail
            // with an `ERC1155InsufficientBalance` error.
            vm.expectRevert(
                _encodeErc1155InsufficientBalance(address(_app), balance, value, tokenId)
            );
            _app.executeOutput(output, proof);
        }

        // In order to successfully execute the voucher,
        // we need to transfer some tokens to the app contract.
        vm.prank(tokenOwner);
        token.safeTransferFrom(tokenOwner, address(_app), tokenId, value, new bytes(0));

        // Get the app contract balance before the withdrawal.
        uint256 appBalanceBefore = token.balanceOf(address(_app), tokenId);

        // We get the balance of the destination before the withdrawal.
        uint256 destBalanceBefore = token.balanceOf(destination, tokenId);

        // Finally, we execute the output
        _executeOutput(output, proof);

        // Get the app contract balance after the withdrawal.
        uint256 appBalanceAfter = token.balanceOf(address(_app), tokenId);

        // We get the balance of the destination after the withdrawal.
        uint256 destBalanceAfter = token.balanceOf(destination, tokenId);

        // Make sure the tokens has moved from the app contract
        // to the destination account.
        assertEq(destBalanceAfter, destBalanceBefore + value);
        assertEq(appBalanceAfter, appBalanceBefore - value);
    }

    function testOpenZeppelinErc1155BatchWithdrawal(
        bytes32 tokenIdSeed,
        uint256[] calldata balances,
        bytes calldata data
    ) external {
        // Generate an EOA address for the token owner and token recipient
        // This avoids undesired side effects if the address is zero
        // or if it points to an existing contract.
        address tokenOwner = _randomEoaAddress();
        address destination = _randomEoaAddress();

        // Generate an array of token IDs and values.
        uint256[] memory tokenIds = _generateTokenIds(balances, tokenIdSeed);
        uint256[] memory values = _generateTokenValues(balances);

        // Deploy an OpenZeppelin ERC-1155 token contract.
        IERC1155 token = _deployOpenZeppelinErc1155Token(tokenOwner, tokenIds, balances);

        // We encode the call voucher directly
        bytes memory output = _encodeCallVoucher(
            address(token),
            0,
            _encodeErc1155SafeBatchTransferFrom(
                address(_app), destination, tokenIds, values, data
            )
        );

        // We then add the output to the emulator state.
        uint64 outputIndex = _addOutput(output);

        // We make the output valid and ready for execution
        _makeOutputsValid();

        // Get the output validity proof ready
        OutputValidityProof memory proof = _getOutputValidityProof(outputIndex);

        // Create an array with just the app address so that we can query the
        // app contract balance for each token in a single batch call.
        address[] memory appAddresses = _repeat(address(_app), tokenIds.length);
        uint256[] memory appInitialBalances = token.balanceOfBatch(appAddresses, tokenIds);

        // We check whether the app has enough tokens to make the batch transfer right away.
        // If, for some token, the app doesn't have enough balance, we store the array index
        // so that we can later retrieve the token ID, balance, and value
        // to check for an `ERC1155InsufficientBalance` error.
        // We know that we need to scan the array from index `0` to `length-1`
        // because we know we are dealing with an OpenZeppelin ERC-1155 token contract
        // and are able to inspect its source code. :-)
        bool hasInsufficientBalance;
        uint256 insufficientBalanceIndex;
        for (uint256 i; i < appInitialBalances.length; ++i) {
            if (appInitialBalances[i] < values[i]) {
                hasInsufficientBalance = true;
                insufficientBalanceIndex = i;
                break;
            }
        }

        if (hasInsufficientBalance) {
            // If, for some token, the value is greater than the app contract balance,
            // then executing the voucher right away will fail
            // with an `ERC1155InsufficientBalance` error.
            vm.expectRevert(
                _encodeErc1155InsufficientBalance(
                    address(_app),
                    appInitialBalances[insufficientBalanceIndex],
                    values[insufficientBalanceIndex],
                    tokenIds[insufficientBalanceIndex]
                )
            );
            _app.executeOutput(output, proof);
        }

        // In order to successfully execute the voucher,
        // we need to transfer some tokens to the app contract.
        vm.prank(tokenOwner);
        token.safeBatchTransferFrom(
            tokenOwner, address(_app), tokenIds, values, new bytes(0)
        );

        // Get the app contract balances before the withdrawal.
        uint256[] memory appBalancesBefore = token.balanceOfBatch(appAddresses, tokenIds);

        // We get the balances of the destination before the withdrawal.
        address[] memory destinations = _repeat(destination, tokenIds.length);
        uint256[] memory destBalancesBefore = token.balanceOfBatch(destinations, tokenIds);

        // Finally, we execute the output
        _executeOutput(output, proof);

        // Get the app contract balances after the withdrawal.
        uint256[] memory appBalancesAfter = token.balanceOfBatch(appAddresses, tokenIds);

        // We get the balances of the destination after the withdrawal.
        uint256[] memory destBalancesAfter = token.balanceOfBatch(destinations, tokenIds);

        // Make sure the tokens has moved from the app contract to the destination account.
        for (uint256 i; i < tokenIds.length; ++i) {
            uint256 value = values[i];
            assertEq(destBalancesAfter[i], destBalancesBefore[i] + value);
            assertEq(appBalancesAfter[i], appBalancesBefore[i] - value);
        }
    }

    // -----------------
    // Virtual functions
    // -----------------

    /// @notice Prepare for an epoch to be finalized.
    /// @param epochIndex The epoch index
    /// @param epochFinalizer The epoch finalizer
    /// @param postEpochStateRoot The post-epoch state root that `AppTest` wants to be valid
    /// @dev This virtual function is used by `AppTest` to test the epoch manager and outbox.
    /// @dev `AppTest` should be able to call `finalizeEpoch` with the given post-epoch state afterwards.
    function _preFinalizeEpoch(
        uint256 epochIndex,
        address epochFinalizer,
        bytes32 postEpochStateRoot
    ) internal virtual;

    // ------------------
    // Internal functions
    // ------------------

    /// @notice Add an input and ensure that an `InputAdded` event is emitted
    /// with the correctly-encoded input as argument, and that `getInputMerkleRoot`
    /// returns the same value returned by `addInput`.
    function _testAddInput(bytes memory payload, uint256 inputIndex) internal {
        bytes memory input = _encodeInput(inputIndex, address(this), payload);
        vm.expectEmit(true, false, false, true, address(_app));
        emit Inbox.InputAdded(inputIndex, input);
        bytes32 inputMerkleRoot = _app.addInput(payload);
        assertEq(_app.getInputMerkleRoot(inputIndex), inputMerkleRoot);
    }

    /// @notice Compute the maximum input payload length.
    function _computeMaxInputPayloadLength() internal view returns (uint256) {
        // First, we encode an input with an empty payload.
        // The encoded input includes the payload offset and size,
        // as well as all the fixed-size EVM metadata.
        bytes memory input = _encodeInput(0, address(0), new bytes(0));

        // Then, we subtract the size of the input from the maximum input size
        // and round down to the closest power of 32 (because the payload is
        // padded into 32-byte EVM words).
        return 32 * ((CanonicalMachine.INPUT_MAX_SIZE - input.length) / 32);
    }

    /// @notice Encode an input.
    /// @param inputIndex The input index
    /// @param inputSender The input sender
    /// @param payload The input payload
    /// @return The input
    function _encodeInput(uint256 inputIndex, address inputSender, bytes memory payload)
        internal
        view
        returns (bytes memory)
    {
        return abi.encodeCall(
            Inputs.EvmAdvance,
            (
                block.chainid,
                address(_app),
                inputSender,
                vm.getBlockNumber(),
                vm.getBlockTimestamp(),
                block.prevrandao,
                inputIndex,
                payload
            )
        );
    }

    /// @notice Encode a `CannotCloseEmptyEpoch` error.
    /// @param epochIndex The epoch index
    /// @return The encoded error
    function _encodeCannotCloseEmptyEpoch(uint256 epochIndex)
        internal
        pure
        returns (bytes memory)
    {
        return abi.encodeWithSelector(
            EpochManager.CannotCloseEmptyEpoch.selector, epochIndex
        );
    }

    /// @notice Encode an `InvalidPostEpochState` error.
    /// @param epochIndex The epoch index
    /// @param postEpochStateRoot The invalid post-epoch state root
    /// @return The encoded error
    function _encodeInvalidPostEpochState(uint256 epochIndex, bytes32 postEpochStateRoot)
        internal
        pure
        returns (bytes memory)
    {
        return abi.encodeWithSelector(
            EpochManager.InvalidPostEpochState.selector, epochIndex, postEpochStateRoot
        );
    }

    /// @notice "Mine" a block, that is, increment the block number by 1.
    function _mineBlock() internal {
        vm.roll(vm.getBlockNumber() + 1);
    }

    /// @notice Generates a random outputs root proof.
    /// @return proof A random outputs root proof
    function _randomOutputsRootProof() internal view returns (bytes32[] memory) {
        return _randomProof(CanonicalMachine.TREE_HEIGHT);
    }

    /// @notice Generates a random output proof with a given siblings array length.
    /// @return proof A random output proof
    function _randomOutputValidityProof()
        internal
        view
        returns (OutputValidityProof memory)
    {
        return OutputValidityProof({
            outputIndex: _randomOutputIndex(),
            outputHashesSiblings: _randomProof(CanonicalMachine.LOG2_MAX_OUTPUTS)
        });
    }

    function _randomOutputIndex() internal view returns (uint64) {
        return uint64(vm.randomUint(CanonicalMachine.LOG2_MAX_OUTPUTS));
    }

    /// @notice Generates a random proof with a given length.
    /// @param length The length of the proof array
    /// @return proof An array of the given length with random `bytes32` values
    function _randomProof(uint256 length)
        internal
        view
        returns (bytes32[] memory proof)
    {
        proof = new bytes32[](length);
        for (uint256 i; i < proof.length; ++i) {
            proof[i] = bytes32(vm.randomUint());
        }
    }

    /// @notice Compute a post-epoch state root from a post-epoch outputs root and a proof.
    /// @param proof A Merkle proof of the post-epoch outputs root
    /// @param postEpochOutputsRoot The post-epoch outputs root
    /// @return The post-epoch state root
    function _computePostEpochStateRoot(
        bytes32[] memory proof,
        bytes32 postEpochOutputsRoot
    ) internal pure returns (bytes32) {
        return proof.merkleRootAfterReplacement(
            CanonicalMachine.OUTPUTS_ROOT_LEAF_INDEX,
            LibKeccak256.hashBytes(abi.encode(postEpochOutputsRoot))
        );
    }

    /// @notice Computes the address of an EOA from a descriptive string
    /// @param str The string used as seed for the EOA's private key
    /// @return The EOA's address
    function _eoaFromString(string memory str) internal pure returns (address) {
        return vm.addr(boundPrivateKey(uint256(keccak256(abi.encode(str)))));
    }

    /// @notice Encode an ERC-20 `transfer` call.
    /// @param to The token recipient
    /// @param value The transfer value
    /// @return The encoded Solidity function call
    function _encodeErc20Transfer(address to, uint256 value)
        internal
        pure
        returns (bytes memory)
    {
        return abi.encodeCall(IERC20.transfer, (to, value));
    }

    /// @notice Encode an ERC-20 `safeTransfer` call.
    /// @param token The token contract
    /// @param to The token recipient
    /// @param value The transfer value
    /// @return The encoded Solidity function call
    function _encodeErc20SafeTransfer(IERC20 token, address to, uint256 value)
        internal
        pure
        returns (bytes memory)
    {
        return abi.encodeCall(ISafeERC20Transfer.safeTransfer, (token, to, value));
    }

    /// @notice Encode an ERC-20 `transferFrom` call from the application contract.
    /// @param sender The sender address
    /// @param value The transfer value
    /// @return The encoded Solidity function call
    function _encodeErc20TransferFrom(address sender, uint256 value)
        internal
        view
        returns (bytes memory)
    {
        return abi.encodeCall(IERC20.transferFrom, (sender, address(_app), value));
    }

    /// @notice Encode an ERC-721 `safeTransferFrom` call.
    /// @param from The token owner
    /// @param to The token recipient
    /// @param tokenId The token ID
    /// @param data The extra data argument
    /// @return The encoded Solidity function call
    function _encodeErc721SafeTransferFrom(
        address from,
        address to,
        uint256 tokenId,
        bytes calldata data
    ) internal pure returns (bytes memory) {
        return abi.encodeWithSignature(
            "safeTransferFrom(address,address,uint256,bytes)", from, to, tokenId, data
        );
    }

    /// @notice Encode an ERC-1155 `safeTransferFrom` call from the application contract.
    /// @param from The token owner
    /// @param to The token receiver
    /// @param tokenId The token ID
    /// @param value The amount of tokens
    /// @param data The extra data argument
    /// @return The encoded Solidity function call
    function _encodeErc1155SafeTransferFrom(
        address from,
        address to,
        uint256 tokenId,
        uint256 value,
        bytes calldata data
    ) internal pure returns (bytes memory) {
        return abi.encodeCall(IERC1155.safeTransferFrom, (from, to, tokenId, value, data));
    }

    /// @notice Encode an ERC-1155 `safeBatchTransferFrom` call from the application contract.
    /// @param from The token owner
    /// @param to The token receiver
    /// @param tokenIds The token IDs
    /// @param values The amounts for each token
    /// @param data The extra data argument
    /// @return The encoded Solidity function call
    function _encodeErc1155SafeBatchTransferFrom(
        address from,
        address to,
        uint256[] memory tokenIds,
        uint256[] memory values,
        bytes calldata data
    ) internal pure returns (bytes memory) {
        return abi.encodeCall(
            IERC1155.safeBatchTransferFrom, (from, to, tokenIds, values, data)
        );
    }

    /// @notice Encode an `ERC20InsufficientAllowance` error related to the ERC-20 portal.
    /// @param insufficientAllowance The insufficient allowance
    /// @param neededAllowance The needed allowance
    /// @return The encoded Solidity error
    function _encodeErc20InsufficientAllowance(
        uint256 insufficientAllowance,
        uint256 neededAllowance
    ) internal view returns (bytes memory) {
        return abi.encodeWithSelector(
            IERC20Errors.ERC20InsufficientAllowance.selector,
            address(ERC20_PORTAL),
            insufficientAllowance,
            neededAllowance
        );
    }

    /// @notice Encode an `ERC20InsufficientBalance` error.
    /// @param tokenSender The token sender
    /// @param insufficientBalance The insufficient balance
    /// @param neededBalance The needed balance
    /// @return The encoded Solidity error
    function _encodeErc20InsufficientBalance(
        address tokenSender,
        uint256 insufficientBalance,
        uint256 neededBalance
    ) internal pure returns (bytes memory) {
        return abi.encodeWithSelector(
            IERC20Errors.ERC20InsufficientBalance.selector,
            tokenSender,
            insufficientBalance,
            neededBalance
        );
    }

    /// @notice Encode an `ERC721InsufficientApproval` error.
    /// @param operator The transfer operator
    /// @param tokenId The token ID
    /// @return The encoded Solidity error
    function _encodeErc721InsufficientApproval(address operator, uint256 tokenId)
        internal
        pure
        returns (bytes memory)
    {
        return abi.encodeWithSelector(
            IERC721Errors.ERC721InsufficientApproval.selector, operator, tokenId
        );
    }

    /// @notice Encode an `ERC721IncorrectOwner` error related to the ERC-721 portal.
    /// @param sender The token sender
    /// @param tokenId The token ID
    /// @param owner The token owner
    /// @return The encoded Solidity error
    function _encodeErc721IncorrectOwner(address sender, uint256 tokenId, address owner)
        internal
        pure
        returns (bytes memory)
    {
        return abi.encodeWithSelector(
            IERC721Errors.ERC721IncorrectOwner.selector, sender, tokenId, owner
        );
    }

    /// @notice Encode an `ERC721NonexistentToken` error.
    /// @param tokenId The nonexistent token ID
    /// @return The encoded Solidity error
    function _encodeErc721NonexistentToken(uint256 tokenId)
        internal
        pure
        returns (bytes memory)
    {
        return
            abi.encodeWithSelector(IERC721Errors.ERC721NonexistentToken.selector, tokenId);
    }

    /// @notice Encode an `ERC1155MissingApprovalForAll` error.
    /// @param operator The transfer operator
    /// @param owner The token owner
    /// @return The encoded Solidity error
    function _encodeErc1155MissingApprovalForAll(address operator, address owner)
        internal
        pure
        returns (bytes memory)
    {
        return abi.encodeWithSelector(
            IERC1155Errors.ERC1155MissingApprovalForAll.selector, operator, owner
        );
    }

    /// @notice Encode an `ERC1155InsufficientBalance` error.
    /// @param tokenSender The token sender
    /// @param insufficientBalance The insufficient balance
    /// @param neededBalance The needed balance
    /// @param tokenId The token ID
    /// @return The encoded Solidity error
    function _encodeErc1155InsufficientBalance(
        address tokenSender,
        uint256 insufficientBalance,
        uint256 neededBalance,
        uint256 tokenId
    ) internal pure returns (bytes memory) {
        return abi.encodeWithSelector(
            IERC1155Errors.ERC1155InsufficientBalance.selector,
            tokenSender,
            insufficientBalance,
            neededBalance,
            tokenId
        );
    }

    /// @notice Encode an `ERC1155InvalidArrayLength` error.
    /// @param tokenIdsLength The length of the tokens array
    /// @param valuesLength The length of the values array
    /// @return The encoded Solidity error
    function _encodeErc1155InvalidArrayLength(
        uint256 tokenIdsLength,
        uint256 valuesLength
    ) internal pure returns (bytes memory) {
        return abi.encodeWithSelector(
            IERC1155Errors.ERC1155InvalidArrayLength.selector,
            tokenIdsLength,
            valuesLength
        );
    }

    /// @notice Encode an `InvalidOutputsMerkleRoot` error.
    /// @param outputsRoot The invalid outputs Merkle root
    /// @return The encoded Solidity error
    function _encodeInvalidOutputsMerkleRoot(bytes32 outputsRoot)
        internal
        pure
        returns (bytes memory)
    {
        return
            abi.encodeWithSelector(Outbox.InvalidOutputsMerkleRoot.selector, outputsRoot);
    }

    /// @notice Encode an `OutputNotReexecutable` error.
    /// @param output The output
    /// @return The encoded Solidity error
    function _encodeOutputNotReexecutable(bytes memory output)
        internal
        pure
        returns (bytes memory)
    {
        return abi.encodeWithSelector(Outbox.OutputNotReexecutable.selector, output);
    }

    /// @notice Encode an `OutputNotExecutable` error.
    /// @param output The output
    /// @return The encoded Solidity error
    function _encodeOutputNotExecutable(bytes memory output)
        internal
        pure
        returns (bytes memory)
    {
        return abi.encodeWithSelector(Outbox.OutputNotExecutable.selector, output);
    }

    /// @notice Encode an `InsufficientFunds` error.
    /// @param value The value being attempted to be transferred
    /// @param balance The contract balance
    /// @return The encoded Solidity error
    function _encodeInsufficientFunds(uint256 value, uint256 balance)
        internal
        pure
        returns (bytes memory)
    {
        return abi.encodeWithSelector(Outbox.InsufficientFunds.selector, value, balance);
    }

    /// @notice Deploy an OpenZeppelin's ERC-20 token contract.
    /// @param tokenOwner The account that holds all the token supply initially
    /// @param tokenSupply The token supply
    /// @return The ERC-20 token contract
    function _deployOpenZeppelinErc20Token(address tokenOwner, uint256 tokenSupply)
        internal
        returns (IERC20)
    {
        return new SimpleERC20(tokenOwner, tokenSupply);
    }

    /// @notice Deploy an OpenZeppelin's ERC-721 token contract.
    /// @param tokenOwner The account that holds all the token supply initially
    /// @param tokenId The token ID
    /// @return The ERC-721 token contract
    function _deployOpenZeppelinErc721Token(address tokenOwner, uint256 tokenId)
        internal
        returns (IERC721)
    {
        return new SimpleERC721(tokenOwner, tokenId);
    }

    /// @notice Deploy an OpenZeppelin's ERC-1155 token contract that mints a single type of token.
    /// @param tokenOwner The account that holds all the token supply initially
    /// @param tokenId The token ID
    /// @param tokenSupply The token supply
    /// @return The ERC-1155 token contract
    function _deployOpenZeppelinErc1155Token(
        address tokenOwner,
        uint256 tokenId,
        uint256 tokenSupply
    ) internal returns (IERC1155) {
        return new SimpleSingleERC1155(tokenOwner, tokenId, tokenSupply);
    }

    /// @notice Deploy an OpenZeppelin's ERC-1155 token contract that mints several types of tokens.
    /// @param tokenOwner The account that holds all the token supply initially
    /// @param tokenIds The token IDs
    /// @param tokenSupplies The token supplies
    /// @return The ERC-1155 token contract
    function _deployOpenZeppelinErc1155Token(
        address tokenOwner,
        uint256[] memory tokenIds,
        uint256[] memory tokenSupplies
    ) internal returns (IERC1155) {
        return new SimpleBatchERC1155(tokenOwner, tokenIds, tokenSupplies);
    }

    /// @notice Generate an array of token IDs.
    /// @param balances The array of balances
    /// @param seed A seed value to increase entropy
    function _generateTokenIds(uint256[] calldata balances, bytes32 seed)
        internal
        pure
        returns (uint256[] memory tokenIds)
    {
        tokenIds = new uint256[](balances.length);
        for (uint256 i; i < tokenIds.length; ++i) {
            tokenIds[i] = uint256(keccak256(abi.encode(seed, i)));
        }
    }

    /// @notice Generate an array of token values.
    /// @param balances The array of balances
    function _generateTokenValues(uint256[] calldata balances)
        internal
        view
        returns (uint256[] memory tokenValues)
    {
        tokenValues = new uint256[](balances.length);
        for (uint256 i; i < balances.length; ++i) {
            tokenValues[i] = vm.randomUint(0, balances[i]);
        }
    }

    /// @notice Close a given epoch and return the epoch finalizer.
    /// @param epochIndex The epoch index
    /// @return epochFinalizer The epoch finalizer
    /// @dev Assumes the epoch can be closed.
    function _closeEpoch(uint256 epochIndex) internal returns (address epochFinalizer) {
        // Start recording logs so that we can capture
        // the emission of the `EpochClosed` event.
        vm.recordLogs();

        // We close the epoch given its index.
        _app.closeEpoch(epochIndex);

        // We retrieve the logs emitted
        // during the `closeEpoch` function call.
        Vm.Log[] memory entries = vm.getRecordedLogs();

        uint256 numOfEpochsClosed;

        for (uint256 i; i < entries.length; ++i) {
            Vm.Log memory entry = entries[i];

            // We check if the log was emitted by the app contract
            // and whether its topic 0 matches the `EpochClosed` selector.
            if (
                entry.emitter == address(_app)
                    && entry.topics[0] == EpochManager.EpochClosed.selector
            ) {
                ++numOfEpochsClosed;

                // We extract the epoch finalizer from the topic 2 of the `EpochClosed` event.
                epochFinalizer = address(uint160(uint256(entry.topics[2])));

                // We extract the epoch index from the topic 1 of the `EpochClosed` event
                // and compare it against the one provided to the `closeEpoch` function.
                assertEq(uint256(entry.topics[1]), epochIndex);
            }
        }

        // We ensure only one epoch was closed.
        assertEq(numOfEpochsClosed, 1);

        // We ensure the epoch finalizer address has code.
        assertGt(epochFinalizer.code.length, 0);
    }

    /// @notice Add an empty input.
    function _addEmptyInput() internal {
        _app.addInput(new bytes(0));
    }

    /// @notice Add an output to the emulator state.
    /// @param output The output
    /// @return index The output index
    function _addOutput(bytes memory output) internal returns (uint64 index) {
        return _emulator.addOutput(output);
    }

    /// @notice Add a list of outputs to the emulator state.
    /// @param outputs The list of outputs
    /// @return indices The output indices
    function _addOutputs(bytes[] memory outputs)
        internal
        returns (uint64[] memory indices)
    {
        indices = new uint64[](outputs.length);
        for (uint256 i; i < outputs.length; ++i) {
            indices[i] = _addOutput(outputs[i]);
        }
    }

    /// @notice Make the current set of outputs valid.
    /// @dev Assumes the last non-finalized epoch is open.
    function _makeOutputsValid() internal {
        // Add a single empty input just so that we can close the epoch
        // We store the epoch finalizer so that we can finalize the epoch later
        _addEmptyInput();
        _mineBlock();
        uint256 epochIndex = _app.getFinalizedEpochCount();
        address epochFinalizer = _closeEpoch(epochIndex);

        // We then compute the outputs root
        bytes32 outputsRoot = _emulator.getOutputsMerkleRoot();

        // And then we finalize the epoch
        bytes32[] memory proof = _randomOutputsRootProof();
        bytes32 postEpochStateRoot = _computePostEpochStateRoot(proof, outputsRoot);
        _preFinalizeEpoch(epochIndex, epochFinalizer, postEpochStateRoot);
        _app.finalizeEpoch(epochIndex, outputsRoot, proof);
        assertTrue(_app.isOutputsRootFinal(outputsRoot));
    }

    /// @notice Generate a random typed output kind.
    function _randomTypedOutputKind() internal view returns (uint256) {
        uint256 x = vm.randomUint(0, 2);
        if (x == 0) {
            return NOTICE;
        } else if (x == 1) {
            return CALL_VOUCHER;
        } else if (x == 2) {
            return DELEGATECALL_VOUCHER;
        } else {
            revert("invalid random uint");
        }
    }

    /// @notice Check whether a typed output is executable by its kind.
    /// @param typedOutput The typed output
    function _isTypedOutputExecutable(TypedOutput memory typedOutput)
        internal
        pure
        returns (bool)
    {
        uint256 kind = typedOutput.kind;
        return kind == CALL_VOUCHER || kind == DELEGATECALL_VOUCHER;
    }

    /// @notice This error is raised when one tries to encode a typed
    /// output with an unknown kind field.
    /// @param kind The unknown kind
    error UnknownTypedOutputKind(uint256 kind);

    /// @notice Encode a typed output
    /// @param typedOutput The typed output struct
    /// @return output The encoded typed output
    function _encodeTypedOutput(TypedOutput memory typedOutput)
        internal
        pure
        returns (bytes memory output)
    {
        uint256 kind = typedOutput.kind;
        address destination = typedOutput.destination;
        uint256 value = typedOutput.value;
        bytes memory payload = typedOutput.payload;
        if (kind == NOTICE) {
            return _encodeNotice(payload);
        } else if (kind == CALL_VOUCHER) {
            return _encodeCallVoucher(destination, value, payload);
        } else if (kind == DELEGATECALL_VOUCHER) {
            return _encodeDelegateCallVoucher(destination, payload);
        } else {
            revert UnknownTypedOutputKind(kind);
        }
    }

    /// @notice Encode a notice
    /// @param payload The notice payload
    /// @return output The encoded notice
    function _encodeNotice(bytes memory payload)
        internal
        pure
        returns (bytes memory output)
    {
        return abi.encodeCall(Outputs.Notice, (payload));
    }

    /// @notice Encode a CALL voucher
    /// @param destination The CALL destination
    /// @param value The CALL value in Wei
    /// @param payload The CALL payload
    /// @return output The encoded CALL voucher
    function _encodeCallVoucher(address destination, uint256 value, bytes memory payload)
        internal
        pure
        returns (bytes memory output)
    {
        return abi.encodeCall(Outputs.Voucher, (destination, value, payload));
    }

    /// @notice Encode a DELEGATECALL voucher
    /// @param destination The DELEGATECALL destination
    /// @param payload The DELEGATECALL payload
    /// @return output The encoded DELEGATECALL voucher
    function _encodeDelegateCallVoucher(address destination, bytes memory payload)
        internal
        pure
        returns (bytes memory output)
    {
        return abi.encodeCall(Outputs.DelegateCallVoucher, (destination, payload));
    }

    /// @notice Get a validity proof for a given output.
    /// @param outputIndex The output index
    /// @return The output validity proof
    function _getOutputValidityProof(uint64 outputIndex)
        internal
        view
        returns (OutputValidityProof memory)
    {
        return _emulator.getOutputValidityProof(outputIndex);
    }

    /// @notice Generate a random EOA address
    function _randomEoaAddress() internal view returns (address) {
        return vm.addr(boundPrivateKey(vm.randomUint()));
    }

    /// @notice Shuffles an array of `uint64` values.
    /// @param inputArray The input array
    /// @return outputArray The output array
    function _shuffle(uint64[] memory inputArray)
        internal
        returns (uint64[] memory outputArray)
    {
        uint256[] memory indices = vm.shuffle(_range(0, inputArray.length));
        assert(indices.length == inputArray.length);
        outputArray = new uint64[](inputArray.length);
        for (uint256 i; i < outputArray.length; ++i) {
            assert(indices[i] >= 0 && indices[i] < inputArray.length);
            outputArray[i] = inputArray[indices[i]];
        }
    }

    /// @notice Create a sorted array with all elements in the interval [inclusiveStart, exclusiveEnd).
    /// @param inclusiveStart The inclusive start of the interval
    /// @param exclusiveEnd The exclusive end of the interval
    /// @return arr The output array
    function _range(uint256 inclusiveStart, uint256 exclusiveEnd)
        internal
        pure
        returns (uint256[] memory arr)
    {
        if (inclusiveStart < exclusiveEnd) {
            arr = new uint256[](exclusiveEnd - inclusiveStart);
            for (uint256 i; i < arr.length; ++i) {
                arr[i] = inclusiveStart + i;
                assert(inclusiveStart <= arr[i] && arr[i] < exclusiveEnd);
            }
        } else {
            arr = new uint256[](0);
        }
    }

    /// @notice Execute an output while checking whether it emits an `OutputExecuted` event,
    /// whether the value returned by the `wasOutputExecuted` function goes from `false` to `true`,
    /// and whether the value returned by the `getNumberOfExecutedOutputs` function increases by 1.
    /// It also checks whether trying to execute the output again raises `OutputNotReexecutable`,
    /// and that it can still be validated after execution.
    /// @param output The output
    /// @param proof The output validity proof
    function _executeOutput(bytes memory output, OutputValidityProof memory proof)
        internal
    {
        // Get the number of executed outputs before the execution
        uint256 numOfExecutedOutputs = _app.getNumberOfExecutedOutputs();

        // Make sure the output was not executed yet
        assertFalse(_app.wasOutputExecuted(proof.outputIndex));

        // Expect an `OutputExecuted` event to be emitted with the right index and output args
        vm.expectEmit(false, false, false, true, address(_app));
        emit Outbox.OutputExecuted(proof.outputIndex, output);

        // Finally, we execute the output
        _app.executeOutput(output, proof);

        // Make sure the output was executed
        assertTrue(_app.wasOutputExecuted(proof.outputIndex));

        // Make sure the number of executed output has increased by 1
        assertEq(_app.getNumberOfExecutedOutputs(), numOfExecutedOutputs + 1);

        // Trying to execute the output again reverts.
        vm.expectRevert(_encodeOutputNotReexecutable(output));
        _app.executeOutput(output, proof);

        // We can still validate the output and its hash afterhand.
        _app.validateOutput(output, proof);
        _app.validateOutputHash(keccak256(output), proof);
    }

    /// @notice Crete an array with `n` elements, all of which are `addr`.
    /// @param addr The address value to be repeated `n` times
    /// @param n The number of elements in the array
    /// @return addrs The array of addresses
    function _repeat(address addr, uint256 n)
        internal
        pure
        returns (address[] memory addrs)
    {
        addrs = new address[](n);
        for (uint256 i; i < n; ++i) {
            addrs[i] = addr;
        }
    }
}
