{
  "address": "0x922a84c4a6dED3598Dd5E2b9c7575CF652049E3A",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract IInputBox",
          "name": "inputBox",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "contract IERC721",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "appContract",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "baseLayerData",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "execLayerData",
          "type": "bytes"
        }
      ],
      "name": "depositERC721Token",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getInputBox",
      "outputs": [
        {
          "internalType": "contract IInputBox",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "interfaceId",
          "type": "bytes4"
        }
      ],
      "name": "supportsInterface",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xa9cfbda4483913035ee0a693e1435717c54d65df46d214a4bde7383ba5763f96",
  "receipt": {
    "to": "0x914d7Fec6aaC8cd542e72Bca78B30650d45643d7",
    "from": "0xB25D9D56f5877Ca869A0362c324aCC2F1465AF1B",
    "contractAddress": null,
    "transactionIndex": 170,
    "gasUsed": "349264",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x99f3c0159b264e48fe11dd4c48d84fa1a4bbc91c36925e97129bd3bf96c72780",
    "transactionHash": "0xa9cfbda4483913035ee0a693e1435717c54d65df46d214a4bde7383ba5763f96",
    "logs": [],
    "blockNumber": 6099737,
    "cumulativeGasUsed": "14868820",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x58Df21fE097d4bE5dCf61e01d9ea3f6B81c2E1dB"
  ],
  "numDeployments": 8,
  "solcInputHash": "d5e580c56a1973c1da5089d8c687e7bd",
  "metadata": "{\"compiler\":{\"version\":\"0.8.23+commit.f704f362\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract IInputBox\",\"name\":\"inputBox\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"appContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"baseLayerData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"execLayerData\",\"type\":\"bytes\"}],\"name\":\"depositERC721Token\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getInputBox\",\"outputs\":[{\"internalType\":\"contract IInputBox\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"constructor\":{\"params\":{\"inputBox\":\"The input box used by the portal\"}},\"depositERC721Token(address,address,uint256,bytes,bytes)\":{\"params\":{\"appContract\":\"The application contract address\",\"baseLayerData\":\"Additional data to be interpreted by the base layer\",\"execLayerData\":\"Additional data to be interpreted by the execution layer\",\"token\":\"The ERC-721 token contract\",\"tokenId\":\"The identifier of the token being transferred\"}},\"getInputBox()\":{\"returns\":{\"_0\":\"The input box\"}}},\"title\":\"ERC-721 Portal\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"constructor\":{\"notice\":\"Constructs the portal.\"},\"depositERC721Token(address,address,uint256,bytes,bytes)\":{\"notice\":\"Transfer an ERC-721 token to an application contract and add an input to the application's input box to signal such operation. The caller must change the approved address for the ERC-721 token to the portal address beforehand, by calling the `approve` function in the token contract.\"},\"getInputBox()\":{\"notice\":\"Get the input box used by this portal.\"}},\"notice\":\"This contract allows anyone to perform transfers of ERC-721 tokens to an application contract while informing the off-chain machine.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/portals/ERC721Portal.sol\":\"ERC721Portal\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` amount of tokens of type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the value of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(\\n        address[] calldata accounts,\\n        uint256[] calldata ids\\n    ) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers a `value` amount of tokens of type `id` from `from` to `to`.\\n     *\\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\\n     * to an untrusted contract, when invoking {onERC1155Received} on the receiver.\\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\\n     * reentrancy guards when interacting with untrusted contracts.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `value` amount.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes calldata data) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\\n     * to an untrusted contract, when invoking {onERC1155BatchReceived} on the receiver.\\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\\n     * reentrancy guards when interacting with untrusted contracts.\\n     *\\n     * Emits either a {TransferSingle} or a {TransferBatch} event, depending on the length of the array arguments.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `values` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external;\\n}\\n\",\"keccak256\":\"0x6caffc9cfdc623eca9f87a686071708af5d5c17454d65022843fdddbc53c0cce\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\",\"keccak256\":\"0xc6a8ff0ea489379b61faa647490411b80102578440ab9d84e9a957cc12164e70\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\\n     *   a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\\n     *   {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\\n     *   a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the address zero.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x5ef46daa3b58ef2702279d514780316efaa952915ee1aa3396f041ee2982b0b4\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\",\"keccak256\":\"0x9e8778b14317ba9e256c30a76fd6c32b960af621987f56069e1e819c77c6a133\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x4296879f55019b23e135000eb36896057e7101fb7fb859c5ef690cf14643757b\",\"license\":\"MIT\"},\"contracts/common/InputEncoding.sol\":{\"content\":\"// (c) Cartesi and individual authors (see AUTHORS)\\n// SPDX-License-Identifier: Apache-2.0 (see LICENSE)\\n\\npragma solidity ^0.8.8;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {IERC721} from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport {IERC1155} from \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\n\\n/// @title Input Encoding Library\\n\\n/// @notice Defines the encoding of inputs added by core trustless and\\n/// permissionless contracts, such as portals.\\nlibrary InputEncoding {\\n    /// @notice Encode an Ether deposit.\\n    /// @param sender The Ether sender\\n    /// @param value The amount of Wei being sent\\n    /// @param execLayerData Additional data to be interpreted by the execution layer\\n    /// @return The encoded input payload\\n    function encodeEtherDeposit(\\n        address sender,\\n        uint256 value,\\n        bytes calldata execLayerData\\n    ) internal pure returns (bytes memory) {\\n        return\\n            abi.encodePacked(\\n                sender, //              20B\\n                value, //               32B\\n                execLayerData //        arbitrary size\\n            );\\n    }\\n\\n    /// @notice Encode an ERC-20 token deposit.\\n    /// @param token The token contract\\n    /// @param sender The token sender\\n    /// @param value The amount of tokens being sent\\n    /// @param execLayerData Additional data to be interpreted by the execution layer\\n    /// @return The encoded input payload\\n    function encodeERC20Deposit(\\n        IERC20 token,\\n        address sender,\\n        uint256 value,\\n        bytes calldata execLayerData\\n    ) internal pure returns (bytes memory) {\\n        return\\n            abi.encodePacked(\\n                token, //               20B\\n                sender, //              20B\\n                value, //               32B\\n                execLayerData //        arbitrary size\\n            );\\n    }\\n\\n    /// @notice Encode an ERC-721 token deposit.\\n    /// @param token The token contract\\n    /// @param sender The token sender\\n    /// @param tokenId The token identifier\\n    /// @param baseLayerData Additional data to be interpreted by the base layer\\n    /// @param execLayerData Additional data to be interpreted by the execution layer\\n    /// @return The encoded input payload\\n    /// @dev `baseLayerData` should be forwarded to `token`.\\n    function encodeERC721Deposit(\\n        IERC721 token,\\n        address sender,\\n        uint256 tokenId,\\n        bytes calldata baseLayerData,\\n        bytes calldata execLayerData\\n    ) internal pure returns (bytes memory) {\\n        bytes memory data = abi.encode(baseLayerData, execLayerData);\\n        return\\n            abi.encodePacked(\\n                token, //               20B\\n                sender, //              20B\\n                tokenId, //             32B\\n                data //                 arbitrary size\\n            );\\n    }\\n\\n    /// @notice Encode an ERC-1155 single token deposit.\\n    /// @param token The ERC-1155 token contract\\n    /// @param sender The token sender\\n    /// @param tokenId The identifier of the token being transferred\\n    /// @param value Transfer amount\\n    /// @param baseLayerData Additional data to be interpreted by the base layer\\n    /// @param execLayerData Additional data to be interpreted by the execution layer\\n    /// @return The encoded input payload\\n    /// @dev `baseLayerData` should be forwarded to `token`.\\n    function encodeSingleERC1155Deposit(\\n        IERC1155 token,\\n        address sender,\\n        uint256 tokenId,\\n        uint256 value,\\n        bytes calldata baseLayerData,\\n        bytes calldata execLayerData\\n    ) internal pure returns (bytes memory) {\\n        bytes memory data = abi.encode(baseLayerData, execLayerData);\\n        return\\n            abi.encodePacked(\\n                token, //               20B\\n                sender, //              20B\\n                tokenId, //             32B\\n                value, //               32B\\n                data //                 arbitrary size\\n            );\\n    }\\n\\n    /// @notice Encode an ERC-1155 batch token deposit.\\n    /// @param token The ERC-1155 token contract\\n    /// @param sender The token sender\\n    /// @param tokenIds The identifiers of the tokens being transferred\\n    /// @param values Transfer amounts per token type\\n    /// @param baseLayerData Additional data to be interpreted by the base layer\\n    /// @param execLayerData Additional data to be interpreted by the execution layer\\n    /// @return The encoded input payload\\n    /// @dev `baseLayerData` should be forwarded to `token`.\\n    function encodeBatchERC1155Deposit(\\n        IERC1155 token,\\n        address sender,\\n        uint256[] calldata tokenIds,\\n        uint256[] calldata values,\\n        bytes calldata baseLayerData,\\n        bytes calldata execLayerData\\n    ) internal pure returns (bytes memory) {\\n        bytes memory data = abi.encode(\\n            tokenIds,\\n            values,\\n            baseLayerData,\\n            execLayerData\\n        );\\n        return\\n            abi.encodePacked(\\n                token, //                   20B\\n                sender, //                  20B\\n                data //                     arbitrary size\\n            );\\n    }\\n}\\n\",\"keccak256\":\"0x1a7e17a9739f27dd761234c388bc6ba30b4aacdf31fc750a29e5c11f0b08bcae\",\"license\":\"Apache-2.0 (see LICENSE)\"},\"contracts/inputs/IInputBox.sol\":{\"content\":\"// (c) Cartesi and individual authors (see AUTHORS)\\n// SPDX-License-Identifier: Apache-2.0 (see LICENSE)\\n\\npragma solidity ^0.8.8;\\n\\n/// @notice Provides data availability of inputs for applications.\\n/// @notice Each application has its own append-only list of inputs.\\n/// @notice Off-chain, inputs can be retrieved via events.\\n/// @notice On-chain, only the input hashes are stored.\\n/// @notice See `LibInput` for more details on how such hashes are computed.\\ninterface IInputBox {\\n    /// @notice MUST trigger when an input is added.\\n    /// @param appContract The application contract address\\n    /// @param index The input index\\n    /// @param input The input blob\\n    event InputAdded(\\n        address indexed appContract,\\n        uint256 indexed index,\\n        bytes input\\n    );\\n\\n    /// @notice Input is too large.\\n    /// @param appContract The application contract address\\n    /// @param inputLength The input length\\n    /// @param maxInputLength The maximum input length\\n    error InputTooLarge(\\n        address appContract,\\n        uint256 inputLength,\\n        uint256 maxInputLength\\n    );\\n\\n    /// @notice Send an input to an application.\\n    /// @param appContract The application contract address\\n    /// @param payload The input payload\\n    /// @return The hash of the input blob\\n    /// @dev MUST fire an `InputAdded` event.\\n    function addInput(\\n        address appContract,\\n        bytes calldata payload\\n    ) external returns (bytes32);\\n\\n    /// @notice Get the number of inputs sent to an application.\\n    /// @param appContract The application contract address\\n    function getNumberOfInputs(\\n        address appContract\\n    ) external view returns (uint256);\\n\\n    /// @notice Get the hash of an input in an application's input box.\\n    /// @param appContract The application contract address\\n    /// @param index The input index\\n    /// @dev The provided index must be valid.\\n    function getInputHash(\\n        address appContract,\\n        uint256 index\\n    ) external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0xae7730cd7ab2b31a86d7c4933215853ea6c0b1b4dc60d4ec24e5cfc2ec005fe3\",\"license\":\"Apache-2.0 (see LICENSE)\"},\"contracts/portals/ERC721Portal.sol\":{\"content\":\"// (c) Cartesi and individual authors (see AUTHORS)\\n// SPDX-License-Identifier: Apache-2.0 (see LICENSE)\\n\\npragma solidity ^0.8.8;\\n\\nimport {IERC721} from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport {IERC165} from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\nimport {IERC721Portal} from \\\"./IERC721Portal.sol\\\";\\nimport {Portal} from \\\"./Portal.sol\\\";\\nimport {IInputBox} from \\\"../inputs/IInputBox.sol\\\";\\nimport {InputEncoding} from \\\"../common/InputEncoding.sol\\\";\\n\\n/// @title ERC-721 Portal\\n///\\n/// @notice This contract allows anyone to perform transfers of\\n/// ERC-721 tokens to an application contract while informing the off-chain machine.\\ncontract ERC721Portal is IERC721Portal, Portal {\\n    /// @notice Constructs the portal.\\n    /// @param inputBox The input box used by the portal\\n    constructor(IInputBox inputBox) Portal(inputBox) {}\\n\\n    function depositERC721Token(\\n        IERC721 token,\\n        address appContract,\\n        uint256 tokenId,\\n        bytes calldata baseLayerData,\\n        bytes calldata execLayerData\\n    ) external override {\\n        token.safeTransferFrom(msg.sender, appContract, tokenId, baseLayerData);\\n\\n        bytes memory payload = InputEncoding.encodeERC721Deposit(\\n            token,\\n            msg.sender,\\n            tokenId,\\n            baseLayerData,\\n            execLayerData\\n        );\\n\\n        _inputBox.addInput(appContract, payload);\\n    }\\n\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view virtual override(IERC165, Portal) returns (bool) {\\n        return\\n            interfaceId == type(IERC721Portal).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n}\\n\",\"keccak256\":\"0xf1c10d9a2960cfee7f80cc71750cb49d4706b8e7fcbd3ae393b268ac8f177430\",\"license\":\"Apache-2.0 (see LICENSE)\"},\"contracts/portals/IERC721Portal.sol\":{\"content\":\"// (c) Cartesi and individual authors (see AUTHORS)\\n// SPDX-License-Identifier: Apache-2.0 (see LICENSE)\\n\\npragma solidity ^0.8.8;\\n\\nimport {IPortal} from \\\"./IPortal.sol\\\";\\nimport {IERC721} from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\n/// @title ERC-721 Portal interface\\ninterface IERC721Portal is IPortal {\\n    // Permissionless functions\\n\\n    /// @notice Transfer an ERC-721 token to an application contract\\n    /// and add an input to the application's input box to signal such operation.\\n    ///\\n    /// The caller must change the approved address for the ERC-721 token\\n    /// to the portal address beforehand, by calling the `approve` function in the\\n    /// token contract.\\n    ///\\n    /// @param token The ERC-721 token contract\\n    /// @param appContract The application contract address\\n    /// @param tokenId The identifier of the token being transferred\\n    /// @param baseLayerData Additional data to be interpreted by the base layer\\n    /// @param execLayerData Additional data to be interpreted by the execution layer\\n    function depositERC721Token(\\n        IERC721 token,\\n        address appContract,\\n        uint256 tokenId,\\n        bytes calldata baseLayerData,\\n        bytes calldata execLayerData\\n    ) external;\\n}\\n\",\"keccak256\":\"0x6efef50a83bbd007d4bdcc856227ebf781a937b692ddf60845f29a4ff9e52918\",\"license\":\"Apache-2.0 (see LICENSE)\"},\"contracts/portals/IPortal.sol\":{\"content\":\"// (c) Cartesi and individual authors (see AUTHORS)\\n// SPDX-License-Identifier: Apache-2.0 (see LICENSE)\\n\\npragma solidity ^0.8.8;\\n\\nimport {IInputBox} from \\\"../inputs/IInputBox.sol\\\";\\nimport {IERC165} from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\n/// @title Portal interface\\ninterface IPortal is IERC165 {\\n    // Permissionless functions\\n\\n    /// @notice Get the input box used by this portal.\\n    /// @return The input box\\n    function getInputBox() external view returns (IInputBox);\\n}\\n\",\"keccak256\":\"0xbc364030939ea4a214e2f3673eaca1c500fcfd4929239a3b5d804ffc5687ed37\",\"license\":\"Apache-2.0 (see LICENSE)\"},\"contracts/portals/Portal.sol\":{\"content\":\"// (c) Cartesi and individual authors (see AUTHORS)\\n// SPDX-License-Identifier: Apache-2.0 (see LICENSE)\\n\\npragma solidity ^0.8.8;\\n\\nimport {IPortal} from \\\"./IPortal.sol\\\";\\nimport {IInputBox} from \\\"../inputs/IInputBox.sol\\\";\\nimport {ERC165, IERC165} from \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\n\\n/// @title Portal\\n/// @notice This contract serves as a base for all the other portals.\\ncontract Portal is IPortal, ERC165 {\\n    /// @notice The input box used by the portal.\\n    IInputBox internal immutable _inputBox;\\n\\n    /// @notice Constructs the portal.\\n    /// @param inputBox The input box used by the portal\\n    constructor(IInputBox inputBox) {\\n        _inputBox = inputBox;\\n    }\\n\\n    function getInputBox() external view override returns (IInputBox) {\\n        return _inputBox;\\n    }\\n\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IPortal).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n}\\n\",\"keccak256\":\"0x0cd3da30a41e1085163195b99526cedced7665c89d291d287500d53e5160e5dc\",\"license\":\"Apache-2.0 (see LICENSE)\"}},\"version\":1}",
  "bytecode": "0x60a060405234801561001057600080fd5b506040516105e13803806105e183398101604081905261002f91610040565b6001600160a01b0316608052610070565b60006020828403121561005257600080fd5b81516001600160a01b038116811461006957600080fd5b9392505050565b608051610550610091600039600081816052015261017501526105506000f3fe608060405234801561001057600080fd5b50600436106100405760003560e01c8062aace9a1461004557806301ffc9a71461008157806328911e83146100a4575b600080fd5b6040516001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001681526020015b60405180910390f35b61009461008f36600461028e565b6100b9565b6040519015158152602001610078565b6100b76100b2366004610320565b6100e4565b005b60006001600160e01b031982166328911e8360e01b14806100de57506100de826101fa565b92915050565b604051635c46a7ef60e11b81526001600160a01b0388169063b88d4fde906101189033908a908a908a908a906004016103e8565b600060405180830381600087803b15801561013257600080fd5b505af1158015610146573d6000803e3d6000fd5b50505050600061015b8833888888888861022e565b604051631789cd6360e01b81529091506001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001690631789cd63906101ac908a90859060040161044b565b6020604051808303816000875af11580156101cb573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101ef919061048d565b505050505050505050565b60006001600160e01b031982166255674d60e11b14806100de57506301ffc9a760e01b6001600160e01b03198316146100de565b606060008585858560405160200161024994939291906104a6565b60405160208183030381529060405290508888888360405160200161027194939291906104cd565b604051602081830303815290604052915050979650505050505050565b6000602082840312156102a057600080fd5b81356001600160e01b0319811681146102b857600080fd5b9392505050565b6001600160a01b03811681146102d457600080fd5b50565b60008083601f8401126102e957600080fd5b50813567ffffffffffffffff81111561030157600080fd5b60208301915083602082850101111561031957600080fd5b9250929050565b600080600080600080600060a0888a03121561033b57600080fd5b8735610346816102bf565b96506020880135610356816102bf565b955060408801359450606088013567ffffffffffffffff8082111561037a57600080fd5b6103868b838c016102d7565b909650945060808a013591508082111561039f57600080fd5b506103ac8a828b016102d7565b989b979a50959850939692959293505050565b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b6001600160a01b038681168252851660208201526040810184905260806060820181905260009061041c90830184866103bf565b979650505050505050565b60005b8381101561044257818101518382015260200161042a565b50506000910152565b60018060a01b03831681526040602082015260008251806040840152610478816060850160208701610427565b601f01601f1916919091016060019392505050565b60006020828403121561049f57600080fd5b5051919050565b6040815260006104ba6040830186886103bf565b828103602084015261041c8185876103bf565b60006bffffffffffffffffffffffff19808760601b168352808660601b16601484015250836028830152825161050a816048850160208701610427565b919091016048019594505050505056fea2646970667358221220f9f739ffb2a36e4d9099273b3917caf01e17d127729777d77dbad6a39366304864736f6c63430008170033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100405760003560e01c8062aace9a1461004557806301ffc9a71461008157806328911e83146100a4575b600080fd5b6040516001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001681526020015b60405180910390f35b61009461008f36600461028e565b6100b9565b6040519015158152602001610078565b6100b76100b2366004610320565b6100e4565b005b60006001600160e01b031982166328911e8360e01b14806100de57506100de826101fa565b92915050565b604051635c46a7ef60e11b81526001600160a01b0388169063b88d4fde906101189033908a908a908a908a906004016103e8565b600060405180830381600087803b15801561013257600080fd5b505af1158015610146573d6000803e3d6000fd5b50505050600061015b8833888888888861022e565b604051631789cd6360e01b81529091506001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001690631789cd63906101ac908a90859060040161044b565b6020604051808303816000875af11580156101cb573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101ef919061048d565b505050505050505050565b60006001600160e01b031982166255674d60e11b14806100de57506301ffc9a760e01b6001600160e01b03198316146100de565b606060008585858560405160200161024994939291906104a6565b60405160208183030381529060405290508888888360405160200161027194939291906104cd565b604051602081830303815290604052915050979650505050505050565b6000602082840312156102a057600080fd5b81356001600160e01b0319811681146102b857600080fd5b9392505050565b6001600160a01b03811681146102d457600080fd5b50565b60008083601f8401126102e957600080fd5b50813567ffffffffffffffff81111561030157600080fd5b60208301915083602082850101111561031957600080fd5b9250929050565b600080600080600080600060a0888a03121561033b57600080fd5b8735610346816102bf565b96506020880135610356816102bf565b955060408801359450606088013567ffffffffffffffff8082111561037a57600080fd5b6103868b838c016102d7565b909650945060808a013591508082111561039f57600080fd5b506103ac8a828b016102d7565b989b979a50959850939692959293505050565b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b6001600160a01b038681168252851660208201526040810184905260806060820181905260009061041c90830184866103bf565b979650505050505050565b60005b8381101561044257818101518382015260200161042a565b50506000910152565b60018060a01b03831681526040602082015260008251806040840152610478816060850160208701610427565b601f01601f1916919091016060019392505050565b60006020828403121561049f57600080fd5b5051919050565b6040815260006104ba6040830186886103bf565b828103602084015261041c8185876103bf565b60006bffffffffffffffffffffffff19808760601b168352808660601b16601484015250836028830152825161050a816048850160208701610427565b919091016048019594505050505056fea2646970667358221220f9f739ffb2a36e4d9099273b3917caf01e17d127729777d77dbad6a39366304864736f6c63430008170033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "constructor": {
        "params": {
          "inputBox": "The input box used by the portal"
        }
      },
      "depositERC721Token(address,address,uint256,bytes,bytes)": {
        "params": {
          "appContract": "The application contract address",
          "baseLayerData": "Additional data to be interpreted by the base layer",
          "execLayerData": "Additional data to be interpreted by the execution layer",
          "token": "The ERC-721 token contract",
          "tokenId": "The identifier of the token being transferred"
        }
      },
      "getInputBox()": {
        "returns": {
          "_0": "The input box"
        }
      }
    },
    "title": "ERC-721 Portal",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "constructor": {
        "notice": "Constructs the portal."
      },
      "depositERC721Token(address,address,uint256,bytes,bytes)": {
        "notice": "Transfer an ERC-721 token to an application contract and add an input to the application's input box to signal such operation. The caller must change the approved address for the ERC-721 token to the portal address beforehand, by calling the `approve` function in the token contract."
      },
      "getInputBox()": {
        "notice": "Get the input box used by this portal."
      }
    },
    "notice": "This contract allows anyone to perform transfers of ERC-721 tokens to an application contract while informing the off-chain machine.",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}