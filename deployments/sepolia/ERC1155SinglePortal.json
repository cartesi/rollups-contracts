{
  "address": "0x7a87676A40aEd3A780Cd8D58c22129D5673eaBc8",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract IInputBox",
          "name": "inputBox",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "contract IERC1155",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "appContract",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "baseLayerData",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "execLayerData",
          "type": "bytes"
        }
      ],
      "name": "depositSingleERC1155Token",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getInputBox",
      "outputs": [
        {
          "internalType": "contract IInputBox",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "interfaceId",
          "type": "bytes4"
        }
      ],
      "name": "supportsInterface",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xb781a0e20b1362abb82c814d97f0992fd4779bf31f7fe4cf480eb9b46794e9dc",
  "receipt": {
    "to": "0x914d7Fec6aaC8cd542e72Bca78B30650d45643d7",
    "from": "0xB25D9D56f5877Ca869A0362c324aCC2F1465AF1B",
    "contractAddress": null,
    "transactionIndex": 130,
    "gasUsed": "358356",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x74dfadd40aa6fcc92a70cdddfe281b2baed59220dd293b6966518175da7cf17f",
    "transactionHash": "0xb781a0e20b1362abb82c814d97f0992fd4779bf31f7fe4cf480eb9b46794e9dc",
    "logs": [],
    "blockNumber": 6099738,
    "cumulativeGasUsed": "13873272",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x58Df21fE097d4bE5dCf61e01d9ea3f6B81c2E1dB"
  ],
  "numDeployments": 4,
  "solcInputHash": "d5e580c56a1973c1da5089d8c687e7bd",
  "metadata": "{\"compiler\":{\"version\":\"0.8.23+commit.f704f362\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract IInputBox\",\"name\":\"inputBox\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"contract IERC1155\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"appContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"baseLayerData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"execLayerData\",\"type\":\"bytes\"}],\"name\":\"depositSingleERC1155Token\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getInputBox\",\"outputs\":[{\"internalType\":\"contract IInputBox\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"constructor\":{\"params\":{\"inputBox\":\"The input box used by the portal\"}},\"depositSingleERC1155Token(address,address,uint256,uint256,bytes,bytes)\":{\"params\":{\"appContract\":\"The application contract address\",\"baseLayerData\":\"Additional data to be interpreted by the base layer\",\"execLayerData\":\"Additional data to be interpreted by the execution layer\",\"token\":\"The ERC-1155 token contract\",\"tokenId\":\"The identifier of the token being transferred\",\"value\":\"Transfer amount\"}},\"getInputBox()\":{\"returns\":{\"_0\":\"The input box\"}}},\"title\":\"ERC-1155 Single Transfer Portal\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"constructor\":{\"notice\":\"Constructs the portal.\"},\"depositSingleERC1155Token(address,address,uint256,uint256,bytes,bytes)\":{\"notice\":\"Transfer ERC-1155 tokens of a single type to an application contract and add an input to the application's input box to signal such operation. The caller must enable approval for the portal to manage all of their tokens beforehand, by calling the `setApprovalForAll` function in the token contract.\"},\"getInputBox()\":{\"notice\":\"Get the input box used by this portal.\"}},\"notice\":\"This contract allows anyone to perform single transfers of ERC-1155 tokens to an application contract while informing the off-chain machine.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/portals/ERC1155SinglePortal.sol\":\"ERC1155SinglePortal\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` amount of tokens of type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the value of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(\\n        address[] calldata accounts,\\n        uint256[] calldata ids\\n    ) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers a `value` amount of tokens of type `id` from `from` to `to`.\\n     *\\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\\n     * to an untrusted contract, when invoking {onERC1155Received} on the receiver.\\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\\n     * reentrancy guards when interacting with untrusted contracts.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `value` amount.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes calldata data) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\\n     * to an untrusted contract, when invoking {onERC1155BatchReceived} on the receiver.\\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\\n     * reentrancy guards when interacting with untrusted contracts.\\n     *\\n     * Emits either a {TransferSingle} or a {TransferBatch} event, depending on the length of the array arguments.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `values` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external;\\n}\\n\",\"keccak256\":\"0x6caffc9cfdc623eca9f87a686071708af5d5c17454d65022843fdddbc53c0cce\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\",\"keccak256\":\"0xc6a8ff0ea489379b61faa647490411b80102578440ab9d84e9a957cc12164e70\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\\n     *   a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\\n     *   {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\\n     *   a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the address zero.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x5ef46daa3b58ef2702279d514780316efaa952915ee1aa3396f041ee2982b0b4\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\",\"keccak256\":\"0x9e8778b14317ba9e256c30a76fd6c32b960af621987f56069e1e819c77c6a133\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x4296879f55019b23e135000eb36896057e7101fb7fb859c5ef690cf14643757b\",\"license\":\"MIT\"},\"contracts/common/InputEncoding.sol\":{\"content\":\"// (c) Cartesi and individual authors (see AUTHORS)\\n// SPDX-License-Identifier: Apache-2.0 (see LICENSE)\\n\\npragma solidity ^0.8.8;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {IERC721} from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport {IERC1155} from \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\n\\n/// @title Input Encoding Library\\n\\n/// @notice Defines the encoding of inputs added by core trustless and\\n/// permissionless contracts, such as portals.\\nlibrary InputEncoding {\\n    /// @notice Encode an Ether deposit.\\n    /// @param sender The Ether sender\\n    /// @param value The amount of Wei being sent\\n    /// @param execLayerData Additional data to be interpreted by the execution layer\\n    /// @return The encoded input payload\\n    function encodeEtherDeposit(\\n        address sender,\\n        uint256 value,\\n        bytes calldata execLayerData\\n    ) internal pure returns (bytes memory) {\\n        return\\n            abi.encodePacked(\\n                sender, //              20B\\n                value, //               32B\\n                execLayerData //        arbitrary size\\n            );\\n    }\\n\\n    /// @notice Encode an ERC-20 token deposit.\\n    /// @param token The token contract\\n    /// @param sender The token sender\\n    /// @param value The amount of tokens being sent\\n    /// @param execLayerData Additional data to be interpreted by the execution layer\\n    /// @return The encoded input payload\\n    function encodeERC20Deposit(\\n        IERC20 token,\\n        address sender,\\n        uint256 value,\\n        bytes calldata execLayerData\\n    ) internal pure returns (bytes memory) {\\n        return\\n            abi.encodePacked(\\n                token, //               20B\\n                sender, //              20B\\n                value, //               32B\\n                execLayerData //        arbitrary size\\n            );\\n    }\\n\\n    /// @notice Encode an ERC-721 token deposit.\\n    /// @param token The token contract\\n    /// @param sender The token sender\\n    /// @param tokenId The token identifier\\n    /// @param baseLayerData Additional data to be interpreted by the base layer\\n    /// @param execLayerData Additional data to be interpreted by the execution layer\\n    /// @return The encoded input payload\\n    /// @dev `baseLayerData` should be forwarded to `token`.\\n    function encodeERC721Deposit(\\n        IERC721 token,\\n        address sender,\\n        uint256 tokenId,\\n        bytes calldata baseLayerData,\\n        bytes calldata execLayerData\\n    ) internal pure returns (bytes memory) {\\n        bytes memory data = abi.encode(baseLayerData, execLayerData);\\n        return\\n            abi.encodePacked(\\n                token, //               20B\\n                sender, //              20B\\n                tokenId, //             32B\\n                data //                 arbitrary size\\n            );\\n    }\\n\\n    /// @notice Encode an ERC-1155 single token deposit.\\n    /// @param token The ERC-1155 token contract\\n    /// @param sender The token sender\\n    /// @param tokenId The identifier of the token being transferred\\n    /// @param value Transfer amount\\n    /// @param baseLayerData Additional data to be interpreted by the base layer\\n    /// @param execLayerData Additional data to be interpreted by the execution layer\\n    /// @return The encoded input payload\\n    /// @dev `baseLayerData` should be forwarded to `token`.\\n    function encodeSingleERC1155Deposit(\\n        IERC1155 token,\\n        address sender,\\n        uint256 tokenId,\\n        uint256 value,\\n        bytes calldata baseLayerData,\\n        bytes calldata execLayerData\\n    ) internal pure returns (bytes memory) {\\n        bytes memory data = abi.encode(baseLayerData, execLayerData);\\n        return\\n            abi.encodePacked(\\n                token, //               20B\\n                sender, //              20B\\n                tokenId, //             32B\\n                value, //               32B\\n                data //                 arbitrary size\\n            );\\n    }\\n\\n    /// @notice Encode an ERC-1155 batch token deposit.\\n    /// @param token The ERC-1155 token contract\\n    /// @param sender The token sender\\n    /// @param tokenIds The identifiers of the tokens being transferred\\n    /// @param values Transfer amounts per token type\\n    /// @param baseLayerData Additional data to be interpreted by the base layer\\n    /// @param execLayerData Additional data to be interpreted by the execution layer\\n    /// @return The encoded input payload\\n    /// @dev `baseLayerData` should be forwarded to `token`.\\n    function encodeBatchERC1155Deposit(\\n        IERC1155 token,\\n        address sender,\\n        uint256[] calldata tokenIds,\\n        uint256[] calldata values,\\n        bytes calldata baseLayerData,\\n        bytes calldata execLayerData\\n    ) internal pure returns (bytes memory) {\\n        bytes memory data = abi.encode(\\n            tokenIds,\\n            values,\\n            baseLayerData,\\n            execLayerData\\n        );\\n        return\\n            abi.encodePacked(\\n                token, //                   20B\\n                sender, //                  20B\\n                data //                     arbitrary size\\n            );\\n    }\\n}\\n\",\"keccak256\":\"0x1a7e17a9739f27dd761234c388bc6ba30b4aacdf31fc750a29e5c11f0b08bcae\",\"license\":\"Apache-2.0 (see LICENSE)\"},\"contracts/inputs/IInputBox.sol\":{\"content\":\"// (c) Cartesi and individual authors (see AUTHORS)\\n// SPDX-License-Identifier: Apache-2.0 (see LICENSE)\\n\\npragma solidity ^0.8.8;\\n\\n/// @notice Provides data availability of inputs for applications.\\n/// @notice Each application has its own append-only list of inputs.\\n/// @notice Off-chain, inputs can be retrieved via events.\\n/// @notice On-chain, only the input hashes are stored.\\n/// @notice See `LibInput` for more details on how such hashes are computed.\\ninterface IInputBox {\\n    /// @notice MUST trigger when an input is added.\\n    /// @param appContract The application contract address\\n    /// @param index The input index\\n    /// @param input The input blob\\n    event InputAdded(\\n        address indexed appContract,\\n        uint256 indexed index,\\n        bytes input\\n    );\\n\\n    /// @notice Input is too large.\\n    /// @param appContract The application contract address\\n    /// @param inputLength The input length\\n    /// @param maxInputLength The maximum input length\\n    error InputTooLarge(\\n        address appContract,\\n        uint256 inputLength,\\n        uint256 maxInputLength\\n    );\\n\\n    /// @notice Send an input to an application.\\n    /// @param appContract The application contract address\\n    /// @param payload The input payload\\n    /// @return The hash of the input blob\\n    /// @dev MUST fire an `InputAdded` event.\\n    function addInput(\\n        address appContract,\\n        bytes calldata payload\\n    ) external returns (bytes32);\\n\\n    /// @notice Get the number of inputs sent to an application.\\n    /// @param appContract The application contract address\\n    function getNumberOfInputs(\\n        address appContract\\n    ) external view returns (uint256);\\n\\n    /// @notice Get the hash of an input in an application's input box.\\n    /// @param appContract The application contract address\\n    /// @param index The input index\\n    /// @dev The provided index must be valid.\\n    function getInputHash(\\n        address appContract,\\n        uint256 index\\n    ) external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0xae7730cd7ab2b31a86d7c4933215853ea6c0b1b4dc60d4ec24e5cfc2ec005fe3\",\"license\":\"Apache-2.0 (see LICENSE)\"},\"contracts/portals/ERC1155SinglePortal.sol\":{\"content\":\"// (c) Cartesi and individual authors (see AUTHORS)\\n// SPDX-License-Identifier: Apache-2.0 (see LICENSE)\\n\\npragma solidity ^0.8.8;\\n\\nimport {IERC1155} from \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\nimport {IERC165} from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\nimport {IERC1155SinglePortal} from \\\"./IERC1155SinglePortal.sol\\\";\\nimport {Portal} from \\\"./Portal.sol\\\";\\nimport {IInputBox} from \\\"../inputs/IInputBox.sol\\\";\\nimport {InputEncoding} from \\\"../common/InputEncoding.sol\\\";\\n\\n/// @title ERC-1155 Single Transfer Portal\\n///\\n/// @notice This contract allows anyone to perform single transfers of\\n/// ERC-1155 tokens to an application contract while informing the off-chain machine.\\ncontract ERC1155SinglePortal is IERC1155SinglePortal, Portal {\\n    /// @notice Constructs the portal.\\n    /// @param inputBox The input box used by the portal\\n    constructor(IInputBox inputBox) Portal(inputBox) {}\\n\\n    function depositSingleERC1155Token(\\n        IERC1155 token,\\n        address appContract,\\n        uint256 tokenId,\\n        uint256 value,\\n        bytes calldata baseLayerData,\\n        bytes calldata execLayerData\\n    ) external override {\\n        token.safeTransferFrom(\\n            msg.sender,\\n            appContract,\\n            tokenId,\\n            value,\\n            baseLayerData\\n        );\\n\\n        bytes memory payload = InputEncoding.encodeSingleERC1155Deposit(\\n            token,\\n            msg.sender,\\n            tokenId,\\n            value,\\n            baseLayerData,\\n            execLayerData\\n        );\\n\\n        _inputBox.addInput(appContract, payload);\\n    }\\n\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view virtual override(IERC165, Portal) returns (bool) {\\n        return\\n            interfaceId == type(IERC1155SinglePortal).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n}\\n\",\"keccak256\":\"0x9c7ae1f9049f30a608fc394ea02644c8f2f40fbae7059d243c568006c86b215f\",\"license\":\"Apache-2.0 (see LICENSE)\"},\"contracts/portals/IERC1155SinglePortal.sol\":{\"content\":\"// (c) Cartesi and individual authors (see AUTHORS)\\n// SPDX-License-Identifier: Apache-2.0 (see LICENSE)\\n\\npragma solidity ^0.8.8;\\n\\nimport {IPortal} from \\\"./IPortal.sol\\\";\\nimport {IERC1155} from \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\n\\n/// @title ERC-1155 Single Transfer Portal interface\\ninterface IERC1155SinglePortal is IPortal {\\n    // Permissionless functions\\n\\n    /// @notice Transfer ERC-1155 tokens of a single type to an application contract\\n    /// and add an input to the application's input box to signal such operation.\\n    ///\\n    /// The caller must enable approval for the portal to manage all of their tokens\\n    /// beforehand, by calling the `setApprovalForAll` function in the token contract.\\n    ///\\n    /// @param token The ERC-1155 token contract\\n    /// @param appContract The application contract address\\n    /// @param tokenId The identifier of the token being transferred\\n    /// @param value Transfer amount\\n    /// @param baseLayerData Additional data to be interpreted by the base layer\\n    /// @param execLayerData Additional data to be interpreted by the execution layer\\n    function depositSingleERC1155Token(\\n        IERC1155 token,\\n        address appContract,\\n        uint256 tokenId,\\n        uint256 value,\\n        bytes calldata baseLayerData,\\n        bytes calldata execLayerData\\n    ) external;\\n}\\n\",\"keccak256\":\"0x0e239fc05c89858218fb6e663ccb7c26171afe6be7e63d4ba93423cf823e445a\",\"license\":\"Apache-2.0 (see LICENSE)\"},\"contracts/portals/IPortal.sol\":{\"content\":\"// (c) Cartesi and individual authors (see AUTHORS)\\n// SPDX-License-Identifier: Apache-2.0 (see LICENSE)\\n\\npragma solidity ^0.8.8;\\n\\nimport {IInputBox} from \\\"../inputs/IInputBox.sol\\\";\\nimport {IERC165} from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\n/// @title Portal interface\\ninterface IPortal is IERC165 {\\n    // Permissionless functions\\n\\n    /// @notice Get the input box used by this portal.\\n    /// @return The input box\\n    function getInputBox() external view returns (IInputBox);\\n}\\n\",\"keccak256\":\"0xbc364030939ea4a214e2f3673eaca1c500fcfd4929239a3b5d804ffc5687ed37\",\"license\":\"Apache-2.0 (see LICENSE)\"},\"contracts/portals/Portal.sol\":{\"content\":\"// (c) Cartesi and individual authors (see AUTHORS)\\n// SPDX-License-Identifier: Apache-2.0 (see LICENSE)\\n\\npragma solidity ^0.8.8;\\n\\nimport {IPortal} from \\\"./IPortal.sol\\\";\\nimport {IInputBox} from \\\"../inputs/IInputBox.sol\\\";\\nimport {ERC165, IERC165} from \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\n\\n/// @title Portal\\n/// @notice This contract serves as a base for all the other portals.\\ncontract Portal is IPortal, ERC165 {\\n    /// @notice The input box used by the portal.\\n    IInputBox internal immutable _inputBox;\\n\\n    /// @notice Constructs the portal.\\n    /// @param inputBox The input box used by the portal\\n    constructor(IInputBox inputBox) {\\n        _inputBox = inputBox;\\n    }\\n\\n    function getInputBox() external view override returns (IInputBox) {\\n        return _inputBox;\\n    }\\n\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IPortal).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n}\\n\",\"keccak256\":\"0x0cd3da30a41e1085163195b99526cedced7665c89d291d287500d53e5160e5dc\",\"license\":\"Apache-2.0 (see LICENSE)\"}},\"version\":1}",
  "bytecode": "0x60a060405234801561001057600080fd5b5060405161060b38038061060b83398101604081905261002f91610040565b6001600160a01b0316608052610070565b60006020828403121561005257600080fd5b81516001600160a01b038116811461006957600080fd5b9392505050565b60805161057a6100916000396000818160520152610178015261057a6000f3fe608060405234801561001057600080fd5b50600436106100405760003560e01c8062aace9a1461004557806301ffc9a714610081578063dec07dca146100a4575b600080fd5b6040516001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001681526020015b60405180910390f35b61009461008f366004610295565b6100b9565b6040519015158152602001610078565b6100b76100b2366004610327565b6100e4565b005b60006001600160e01b03198216636f603ee560e11b14806100de57506100de826101fe565b92915050565b604051637921219560e11b81526001600160a01b0389169063f242432a9061011a9033908b908b908b908b908b906004016103f8565b600060405180830381600087803b15801561013457600080fd5b505af1158015610148573d6000803e3d6000fd5b50505050600061015e8933898989898989610232565b604051631789cd6360e01b81529091506001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001690631789cd63906101af908b908590600401610463565b6020604051808303816000875af11580156101ce573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101f291906104a5565b50505050505050505050565b60006001600160e01b031982166255674d60e11b14806100de57506301ffc9a760e01b6001600160e01b03198316146100de565b606060008585858560405160200161024d94939291906104be565b604051602081830303815290604052905089898989846040516020016102779594939291906104f0565b60405160208183030381529060405291505098975050505050505050565b6000602082840312156102a757600080fd5b81356001600160e01b0319811681146102bf57600080fd5b9392505050565b6001600160a01b03811681146102db57600080fd5b50565b60008083601f8401126102f057600080fd5b50813567ffffffffffffffff81111561030857600080fd5b60208301915083602082850101111561032057600080fd5b9250929050565b60008060008060008060008060c0898b03121561034357600080fd5b883561034e816102c6565b9750602089013561035e816102c6565b96506040890135955060608901359450608089013567ffffffffffffffff8082111561038957600080fd5b6103958c838d016102de565b909650945060a08b01359150808211156103ae57600080fd5b506103bb8b828c016102de565b999c989b5096995094979396929594505050565b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b6001600160a01b03878116825286166020820152604081018590526060810184905260a06080820181905260009061043390830184866103cf565b98975050505050505050565b60005b8381101561045a578181015183820152602001610442565b50506000910152565b60018060a01b0383168152604060208201526000825180604084015261049081606085016020870161043f565b601f01601f1916919091016060019392505050565b6000602082840312156104b757600080fd5b5051919050565b6040815260006104d26040830186886103cf565b82810360208401526104e58185876103cf565b979650505050505050565b60006bffffffffffffffffffffffff19808860601b168352808760601b16601484015250846028830152836048830152825161053381606885016020870161043f565b91909101606801969550505050505056fea264697066735822122033661412ecfee4599f6fb9695aa43c28b25f2c64310271e660ac3ed07b304ea864736f6c63430008170033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100405760003560e01c8062aace9a1461004557806301ffc9a714610081578063dec07dca146100a4575b600080fd5b6040516001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001681526020015b60405180910390f35b61009461008f366004610295565b6100b9565b6040519015158152602001610078565b6100b76100b2366004610327565b6100e4565b005b60006001600160e01b03198216636f603ee560e11b14806100de57506100de826101fe565b92915050565b604051637921219560e11b81526001600160a01b0389169063f242432a9061011a9033908b908b908b908b908b906004016103f8565b600060405180830381600087803b15801561013457600080fd5b505af1158015610148573d6000803e3d6000fd5b50505050600061015e8933898989898989610232565b604051631789cd6360e01b81529091506001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001690631789cd63906101af908b908590600401610463565b6020604051808303816000875af11580156101ce573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101f291906104a5565b50505050505050505050565b60006001600160e01b031982166255674d60e11b14806100de57506301ffc9a760e01b6001600160e01b03198316146100de565b606060008585858560405160200161024d94939291906104be565b604051602081830303815290604052905089898989846040516020016102779594939291906104f0565b60405160208183030381529060405291505098975050505050505050565b6000602082840312156102a757600080fd5b81356001600160e01b0319811681146102bf57600080fd5b9392505050565b6001600160a01b03811681146102db57600080fd5b50565b60008083601f8401126102f057600080fd5b50813567ffffffffffffffff81111561030857600080fd5b60208301915083602082850101111561032057600080fd5b9250929050565b60008060008060008060008060c0898b03121561034357600080fd5b883561034e816102c6565b9750602089013561035e816102c6565b96506040890135955060608901359450608089013567ffffffffffffffff8082111561038957600080fd5b6103958c838d016102de565b909650945060a08b01359150808211156103ae57600080fd5b506103bb8b828c016102de565b999c989b5096995094979396929594505050565b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b6001600160a01b03878116825286166020820152604081018590526060810184905260a06080820181905260009061043390830184866103cf565b98975050505050505050565b60005b8381101561045a578181015183820152602001610442565b50506000910152565b60018060a01b0383168152604060208201526000825180604084015261049081606085016020870161043f565b601f01601f1916919091016060019392505050565b6000602082840312156104b757600080fd5b5051919050565b6040815260006104d26040830186886103cf565b82810360208401526104e58185876103cf565b979650505050505050565b60006bffffffffffffffffffffffff19808860601b168352808760601b16601484015250846028830152836048830152825161053381606885016020870161043f565b91909101606801969550505050505056fea264697066735822122033661412ecfee4599f6fb9695aa43c28b25f2c64310271e660ac3ed07b304ea864736f6c63430008170033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "constructor": {
        "params": {
          "inputBox": "The input box used by the portal"
        }
      },
      "depositSingleERC1155Token(address,address,uint256,uint256,bytes,bytes)": {
        "params": {
          "appContract": "The application contract address",
          "baseLayerData": "Additional data to be interpreted by the base layer",
          "execLayerData": "Additional data to be interpreted by the execution layer",
          "token": "The ERC-1155 token contract",
          "tokenId": "The identifier of the token being transferred",
          "value": "Transfer amount"
        }
      },
      "getInputBox()": {
        "returns": {
          "_0": "The input box"
        }
      }
    },
    "title": "ERC-1155 Single Transfer Portal",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "constructor": {
        "notice": "Constructs the portal."
      },
      "depositSingleERC1155Token(address,address,uint256,uint256,bytes,bytes)": {
        "notice": "Transfer ERC-1155 tokens of a single type to an application contract and add an input to the application's input box to signal such operation. The caller must enable approval for the portal to manage all of their tokens beforehand, by calling the `setApprovalForAll` function in the token contract."
      },
      "getInputBox()": {
        "notice": "Get the input box used by this portal."
      }
    },
    "notice": "This contract allows anyone to perform single transfers of ERC-1155 tokens to an application contract while informing the off-chain machine.",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}