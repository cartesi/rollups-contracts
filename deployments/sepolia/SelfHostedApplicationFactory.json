{
  "address": "0x1fD0E73b5739eDBdf978e3ad2063F86cF78056aF",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract IAuthorityFactory",
          "name": "authorityFactory",
          "type": "address"
        },
        {
          "internalType": "contract IApplicationFactory",
          "name": "applicationFactory",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "authorityOwner",
          "type": "address"
        },
        {
          "internalType": "contract IInputBox",
          "name": "inputBox",
          "type": "address"
        },
        {
          "internalType": "contract IPortal[]",
          "name": "portals",
          "type": "address[]"
        },
        {
          "internalType": "address",
          "name": "appOwner",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "templateHash",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "salt",
          "type": "bytes32"
        }
      ],
      "name": "calculateAddresses",
      "outputs": [
        {
          "internalType": "address",
          "name": "application",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "authority",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "authorityOwner",
          "type": "address"
        },
        {
          "internalType": "contract IInputBox",
          "name": "inputBox",
          "type": "address"
        },
        {
          "internalType": "contract IPortal[]",
          "name": "portals",
          "type": "address[]"
        },
        {
          "internalType": "address",
          "name": "appOwner",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "templateHash",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "salt",
          "type": "bytes32"
        }
      ],
      "name": "deployContracts",
      "outputs": [
        {
          "internalType": "contract Application",
          "name": "application",
          "type": "address"
        },
        {
          "internalType": "contract Authority",
          "name": "authority",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getApplicationFactory",
      "outputs": [
        {
          "internalType": "contract IApplicationFactory",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getAuthorityFactory",
      "outputs": [
        {
          "internalType": "contract IAuthorityFactory",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x806741d143e9db10024f2287c61a71184faf1bb5dfd181c6b7e4343bdceed7cb",
  "receipt": {
    "to": "0x914d7Fec6aaC8cd542e72Bca78B30650d45643d7",
    "from": "0xB25D9D56f5877Ca869A0362c324aCC2F1465AF1B",
    "contractAddress": null,
    "transactionIndex": 62,
    "gasUsed": "358661",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x2cab91b65b490686b44379485d18ec8470ea1f7a66b089faec6f71832b7fcaf9",
    "transactionHash": "0x806741d143e9db10024f2287c61a71184faf1bb5dfd181c6b7e4343bdceed7cb",
    "logs": [],
    "blockNumber": 6099865,
    "cumulativeGasUsed": "5111897",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0xFc6c1Fc6546898eb2f9cb7De360B3eA52E601D46",
    "0x159876e08d642c2Fe9a52804756189E1DbF497F0"
  ],
  "numDeployments": 1,
  "solcInputHash": "d5e580c56a1973c1da5089d8c687e7bd",
  "metadata": "{\"compiler\":{\"version\":\"0.8.23+commit.f704f362\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract IAuthorityFactory\",\"name\":\"authorityFactory\",\"type\":\"address\"},{\"internalType\":\"contract IApplicationFactory\",\"name\":\"applicationFactory\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"authorityOwner\",\"type\":\"address\"},{\"internalType\":\"contract IInputBox\",\"name\":\"inputBox\",\"type\":\"address\"},{\"internalType\":\"contract IPortal[]\",\"name\":\"portals\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"appOwner\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"templateHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"calculateAddresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"application\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"authority\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"authorityOwner\",\"type\":\"address\"},{\"internalType\":\"contract IInputBox\",\"name\":\"inputBox\",\"type\":\"address\"},{\"internalType\":\"contract IPortal[]\",\"name\":\"portals\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"appOwner\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"templateHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"deployContracts\",\"outputs\":[{\"internalType\":\"contract Application\",\"name\":\"application\",\"type\":\"address\"},{\"internalType\":\"contract Authority\",\"name\":\"authority\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getApplicationFactory\",\"outputs\":[{\"internalType\":\"contract IApplicationFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAuthorityFactory\",\"outputs\":[{\"internalType\":\"contract IAuthorityFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"calculateAddresses(address,address,address[],address,bytes32,bytes32)\":{\"params\":{\"appOwner\":\"The initial Application owner\",\"authorityOwner\":\"The initial authority owner\",\"inputBox\":\"The input box contract\",\"portals\":\"The portals supported by the application\",\"salt\":\"The salt used to deterministically generate the addresses\",\"templateHash\":\"The initial machine state hash\"},\"returns\":{\"application\":\"The application address\",\"authority\":\"The authority address\"}},\"constructor\":{\"params\":{\"applicationFactory\":\"The application factory\",\"authorityFactory\":\"The authority factory\"}},\"deployContracts(address,address,address[],address,bytes32,bytes32)\":{\"params\":{\"appOwner\":\"The initial Application owner\",\"authorityOwner\":\"The initial authority owner\",\"inputBox\":\"The input box contract\",\"portals\":\"The portals supported by the application\",\"salt\":\"The salt used to deterministically generate the addresses\",\"templateHash\":\"The initial machine state hash\"},\"returns\":{\"application\":\"The application contract\",\"authority\":\"The authority contract\"}},\"getApplicationFactory()\":{\"returns\":{\"_0\":\"The application factory\"}},\"getAuthorityFactory()\":{\"returns\":{\"_0\":\"The authority factory\"}}},\"title\":\"Self-hosted Application Factory\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"calculateAddresses(address,address,address[],address,bytes32,bytes32)\":{\"notice\":\"Calculate the addresses of the application and authority contracts to be deployed deterministically.\"},\"deployContracts(address,address,address[],address,bytes32,bytes32)\":{\"notice\":\"Deploy new application and authority contracts deterministically.\"},\"getApplicationFactory()\":{\"notice\":\"Get the factory used to deploy `Application` contracts\"},\"getAuthorityFactory()\":{\"notice\":\"Get the factory used to deploy `Authority` contracts\"}},\"notice\":\"Allows anyone to reliably deploy a new Authority contract, along with an Application contract already linked to it.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/dapp/SelfHostedApplicationFactory.sol\":\"SelfHostedApplicationFactory\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0xff6d0bb2e285473e5311d9d3caacb525ae3538a80758c10649a4d61029b017bb\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/IERC1155Receiver.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Interface that must be implemented by smart contracts in order to receive\\n * ERC-1155 token transfers.\\n */\\ninterface IERC1155Receiver is IERC165 {\\n    /**\\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\\n     *\\n     * NOTE: To accept the transfer, this must return\\n     * `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n     * (i.e. 0xf23a6e61, or its own function selector).\\n     *\\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param id The ID of the token being transferred\\n     * @param value The amount of tokens being transferred\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\\n     * been updated.\\n     *\\n     * NOTE: To accept the transfer(s), this must return\\n     * `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n     * (i.e. 0xbc197c81, or its own function selector).\\n     *\\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0xb69597a63b202e28401128bed6a6d259e8730191274471af7303eafb247881a3\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/utils/ERC1155Holder.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165, ERC165} from \\\"../../../utils/introspection/ERC165.sol\\\";\\nimport {IERC1155Receiver} from \\\"../IERC1155Receiver.sol\\\";\\n\\n/**\\n * @dev Simple implementation of `IERC1155Receiver` that will allow a contract to hold ERC1155 tokens.\\n *\\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\\n * stuck.\\n */\\nabstract contract ERC1155Holder is ERC165, IERC1155Receiver {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    function onERC1155Received(\\n        address,\\n        address,\\n        uint256,\\n        uint256,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC1155Received.selector;\\n    }\\n\\n    function onERC1155BatchReceived(\\n        address,\\n        address,\\n        uint256[] memory,\\n        uint256[] memory,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC1155BatchReceived.selector;\\n    }\\n}\\n\",\"keccak256\":\"0xc26cd2e2bcf59b87c986fc653545b35010db9c585a3f3312fe61d7b1b3805735\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be\\n     * reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0x7f7a26306c79a65fb8b3b6c757cd74660c532cd8a02e165488e30027dd34ca49\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/utils/ERC721Holder.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC721Receiver} from \\\"../IERC721Receiver.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC721Receiver} interface.\\n *\\n * Accepts all token transfers.\\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or\\n * {IERC721-setApprovalForAll}.\\n */\\nabstract contract ERC721Holder is IERC721Receiver {\\n    /**\\n     * @dev See {IERC721Receiver-onERC721Received}.\\n     *\\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(address, address, uint256, bytes memory) public virtual returns (bytes4) {\\n        return this.onERC721Received.selector;\\n    }\\n}\\n\",\"keccak256\":\"0xaad20f8713b5cd98114278482d5d91b9758f9727048527d582e8e88fd4901fd8\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\",\"keccak256\":\"0x493033a8d1b176a037b2cc6a04dad01a5c157722049bbecf632ca876224dd4b2\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant NOT_ENTERED = 1;\\n    uint256 private constant ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    /**\\n     * @dev Unauthorized reentrant call.\\n     */\\n    error ReentrancyGuardReentrantCall();\\n\\n    constructor() {\\n        _status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\\n        if (_status == ENTERED) {\\n            revert ReentrancyGuardReentrantCall();\\n        }\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == ENTERED;\\n    }\\n}\\n\",\"keccak256\":\"0xf980daa263b661ab8ddee7d4fd833c7da7e7995e2c359ff1f17e67e4112f2236\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\",\"keccak256\":\"0x9e8778b14317ba9e256c30a76fd6c32b960af621987f56069e1e819c77c6a133\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x4296879f55019b23e135000eb36896057e7101fb7fb859c5ef690cf14643757b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/structs/BitMaps.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/BitMaps.sol)\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Library for managing uint256 to bool mapping in a compact and efficient way, provided the keys are sequential.\\n * Largely inspired by Uniswap's https://github.com/Uniswap/merkle-distributor/blob/master/contracts/MerkleDistributor.sol[merkle-distributor].\\n *\\n * BitMaps pack 256 booleans across each bit of a single 256-bit slot of `uint256` type.\\n * Hence booleans corresponding to 256 _sequential_ indices would only consume a single slot,\\n * unlike the regular `bool` which would consume an entire slot for a single value.\\n *\\n * This results in gas savings in two ways:\\n *\\n * - Setting a zero value to non-zero only once every 256 times\\n * - Accessing the same warm slot for every 256 _sequential_ indices\\n */\\nlibrary BitMaps {\\n    struct BitMap {\\n        mapping(uint256 bucket => uint256) _data;\\n    }\\n\\n    /**\\n     * @dev Returns whether the bit at `index` is set.\\n     */\\n    function get(BitMap storage bitmap, uint256 index) internal view returns (bool) {\\n        uint256 bucket = index >> 8;\\n        uint256 mask = 1 << (index & 0xff);\\n        return bitmap._data[bucket] & mask != 0;\\n    }\\n\\n    /**\\n     * @dev Sets the bit at `index` to the boolean `value`.\\n     */\\n    function setTo(BitMap storage bitmap, uint256 index, bool value) internal {\\n        if (value) {\\n            set(bitmap, index);\\n        } else {\\n            unset(bitmap, index);\\n        }\\n    }\\n\\n    /**\\n     * @dev Sets the bit at `index`.\\n     */\\n    function set(BitMap storage bitmap, uint256 index) internal {\\n        uint256 bucket = index >> 8;\\n        uint256 mask = 1 << (index & 0xff);\\n        bitmap._data[bucket] |= mask;\\n    }\\n\\n    /**\\n     * @dev Unsets the bit at `index`.\\n     */\\n    function unset(BitMap storage bitmap, uint256 index) internal {\\n        uint256 bucket = index >> 8;\\n        uint256 mask = 1 << (index & 0xff);\\n        bitmap._data[bucket] &= ~mask;\\n    }\\n}\\n\",\"keccak256\":\"0x3616f1b0d0a9ee1ca8f0953ecaceb9230e36f691c7974d30f964212acff52d2b\",\"license\":\"MIT\"},\"contracts/common/CanonicalMachine.sol\":{\"content\":\"// (c) Cartesi and individual authors (see AUTHORS)\\n// SPDX-License-Identifier: Apache-2.0 (see LICENSE)\\n\\npragma solidity ^0.8.8;\\n\\n/// @title Canonical Machine Constants Library\\n///\\n/// @notice Defines several constants related to the reference implementation\\n/// of the RISC-V machine that runs Linux, also known as the \\\"Cartesi Machine\\\".\\nlibrary CanonicalMachine {\\n    /// @notice Maximum input size (2 megabytes).\\n    uint256 constant INPUT_MAX_SIZE = 1 << 21;\\n\\n    /// @notice Log of maximum number of inputs per epoch.\\n    uint256 constant LOG2_MAX_INPUTS_PER_EPOCH = 32;\\n\\n    /// @notice Log of maximum number of outputs per input.\\n    uint256 constant LOG2_MAX_OUTPUTS_PER_INPUT = 16;\\n}\\n\",\"keccak256\":\"0xad91c1e0080fd40f53def31cb87106dedef26fc506aa569f43a77b8fcdc53a77\",\"license\":\"Apache-2.0 (see LICENSE)\"},\"contracts/common/InputRange.sol\":{\"content\":\"// (c) Cartesi and individual authors (see AUTHORS)\\n// SPDX-License-Identifier: Apache-2.0 (see LICENSE)\\n\\npragma solidity ^0.8.8;\\n\\n/// @notice A range of input indices.\\n/// @param firstIndex The index of the first input\\n/// @param lastIndex The index of the last input\\nstruct InputRange {\\n    uint64 firstIndex;\\n    uint64 lastIndex;\\n}\\n\",\"keccak256\":\"0x4825516380f1fb39d5b15e99c1b08e07c636dc062ad3036093e78ba8e624cd33\",\"license\":\"Apache-2.0 (see LICENSE)\"},\"contracts/common/OutputValidityProof.sol\":{\"content\":\"// (c) Cartesi and individual authors (see AUTHORS)\\n// SPDX-License-Identifier: Apache-2.0 (see LICENSE)\\n\\npragma solidity ^0.8.8;\\n\\nimport {InputRange} from \\\"./InputRange.sol\\\";\\n\\n/// @param inputRange The range of inputs accepted during the epoch\\n/// @param inputIndexWithinEpoch Which input, inside the epoch, the output belongs to\\n/// @param outputIndexWithinInput Index of output emitted by the input\\n/// @param outputHashesRootHash Merkle root of hashes of outputs emitted by the input\\n/// @param outputsEpochRootHash Merkle root of all epoch's outputs metadata hashes\\n/// @param machineStateHash Hash of the machine state claimed this epoch\\n/// @param outputHashInOutputHashesSiblings Proof that this output metadata is in metadata memory range\\n/// @param outputHashesInEpochSiblings Proof that this output metadata is in epoch's output memory range\\nstruct OutputValidityProof {\\n    InputRange inputRange;\\n    uint64 inputIndexWithinEpoch;\\n    uint64 outputIndexWithinInput;\\n    bytes32 outputHashesRootHash;\\n    bytes32 outputsEpochRootHash;\\n    bytes32 machineStateHash;\\n    bytes32[] outputHashInOutputHashesSiblings;\\n    bytes32[] outputHashesInEpochSiblings;\\n}\\n\",\"keccak256\":\"0xf60efcea5b54d6b5c659460fc205ae04b16d89c72dee86e7b2c1e1edb6a52d65\",\"license\":\"Apache-2.0 (see LICENSE)\"},\"contracts/common/Outputs.sol\":{\"content\":\"// (c) Cartesi and individual authors (see AUTHORS)\\n// SPDX-License-Identifier: Apache-2.0 (see LICENSE)\\n\\npragma solidity ^0.8.8;\\n\\n/// @title Outputs\\n/// @notice Defines the signatures of outputs that can be generated by the\\n/// off-chain machine and verified by the on-chain contracts.\\ninterface Outputs {\\n    /// @notice A piece of verifiable information.\\n    /// @param payload An arbitrary payload.\\n    function Notice(bytes calldata payload) external;\\n\\n    /// @notice A single-use permission to execute a specific message call\\n    /// from the context of the application contract.\\n    /// @param destination The address that will be called\\n    /// @param value The amount of Wei to be transferred through the call\\n    /// @param payload The payload, which\\u2014in the case of Solidity\\n    /// contracts\\u2014encodes a function call\\n    function Voucher(\\n        address destination,\\n        uint256 value,\\n        bytes calldata payload\\n    ) external;\\n\\n    /// @notice A single-use permission to execute a specific delegate call\\n    /// from the context of the application contract.\\n    /// @param destination The address that will be called\\n    /// @param payload The payload, which\\u2014in the case of Solidity\\n    /// libraries\\u2014encodes a function call\\n    function DelegateCallVoucher(\\n        address destination,\\n        bytes calldata payload\\n    ) external;\\n}\\n\",\"keccak256\":\"0xaee9d71104bfe2fab21d4e26f3ed802439d6c2e1bc5aeb9bfc5090f4083bd542\",\"license\":\"Apache-2.0 (see LICENSE)\"},\"contracts/consensus/AbstractConsensus.sol\":{\"content\":\"// (c) Cartesi and individual authors (see AUTHORS)\\n// SPDX-License-Identifier: Apache-2.0 (see LICENSE)\\n\\npragma solidity ^0.8.8;\\n\\nimport {IConsensus} from \\\"./IConsensus.sol\\\";\\nimport {InputRange} from \\\"../common/InputRange.sol\\\";\\n\\n/// @notice Stores epoch hashes for several applications and input ranges.\\n/// @dev This contract was designed to be inherited by implementations of the `IConsensus` interface\\n/// that only need a simple mechanism of storage and retrieval of epoch hashes.\\nabstract contract AbstractConsensus is IConsensus {\\n    /// @notice Indexes epoch hashes by application contract address, first input index and last input index.\\n    mapping(address => mapping(uint256 => mapping(uint256 => bytes32)))\\n        private _epochHashes;\\n\\n    /// @notice Get the epoch hash for a certain application and input range.\\n    /// @param appContract The application contract address\\n    /// @param r The input range\\n    /// @return epochHash The epoch hash\\n    /// @dev For claimed epochs, returns the epoch hash of the last accepted claim.\\n    /// @dev For unclaimed epochs, returns `bytes32(0)`.\\n    function getEpochHash(\\n        address appContract,\\n        InputRange calldata r\\n    ) public view override returns (bytes32 epochHash) {\\n        epochHash = _epochHashes[appContract][r.firstIndex][r.lastIndex];\\n    }\\n\\n    /// @notice Accept a claim.\\n    /// @param appContract The application contract address\\n    /// @param r The input range\\n    /// @param epochHash The epoch hash\\n    /// @dev On successs, emits a `ClaimAcceptance` event.\\n    function _acceptClaim(\\n        address appContract,\\n        InputRange calldata r,\\n        bytes32 epochHash\\n    ) internal {\\n        _epochHashes[appContract][r.firstIndex][r.lastIndex] = epochHash;\\n        emit ClaimAcceptance(appContract, r, epochHash);\\n    }\\n}\\n\",\"keccak256\":\"0x2e41db152b70de9fe9917780efeba10ea3c0e1a1a2c96b158d81b1129a877eb5\",\"license\":\"Apache-2.0 (see LICENSE)\"},\"contracts/consensus/IConsensus.sol\":{\"content\":\"// (c) Cartesi and individual authors (see AUTHORS)\\n// SPDX-License-Identifier: Apache-2.0 (see LICENSE)\\n\\npragma solidity ^0.8.8;\\n\\nimport {InputRange} from \\\"../common/InputRange.sol\\\";\\n\\n/// @notice Provides data availability of epoch hashes for applications.\\n/// @notice An epoch hash is produced after the machine processes a range of inputs and the epoch is finalized.\\n/// This hash can be later used to prove that any given output was produced by the machine during the epoch.\\n/// @notice After an epoch is finalized, a validator may submit a claim containing the application contract address,\\n/// the range of inputs accepted during the epoch, and the epoch hash.\\n/// @notice Validators may synchronize epoch finalization, but such mechanism is not specified by this interface.\\n/// @notice A validator should be able to save transaction fees by not submitting a claim if it was...\\n/// - already submitted by the validator (see the `ClaimSubmission` event) or;\\n/// - already accepted by the consensus (see the `ClaimAcceptance` event).\\n/// @notice The acceptance criteria for claims may depend on the type of consensus, and is not specified by this interface.\\n/// For example, a claim may be accepted if it was...\\n/// - submitted by an authority or;\\n/// - submitted by the majority of a quorum or;\\n/// - submitted and not proven wrong after some period of time.\\ninterface IConsensus {\\n    /// @notice MUST trigger when a claim is submitted.\\n    /// @param submitter The submitter address\\n    /// @param appContract The application contract address\\n    /// @param inputRange The input range\\n    /// @param epochHash The epoch hash\\n    /// @dev Overwrites any previous submissions regarding `submitter`, `appContract` and `inputRange`.\\n    event ClaimSubmission(\\n        address indexed submitter,\\n        address indexed appContract,\\n        InputRange inputRange,\\n        bytes32 epochHash\\n    );\\n\\n    /// @notice MUST trigger when a claim is accepted.\\n    /// @param appContract The application contract address\\n    /// @param inputRange The input range\\n    /// @param epochHash The epoch hash\\n    /// @dev MUST be triggered after some `ClaimSubmission` event regarding `appContract`, `inputRange` and `epochHash`.\\n    /// @dev Overwrites any previous acceptances regarding `appContract` and `inputRange`.\\n    event ClaimAcceptance(\\n        address indexed appContract,\\n        InputRange inputRange,\\n        bytes32 epochHash\\n    );\\n\\n    /// @notice Submit a claim to the consensus.\\n    /// @param appContract The application contract address\\n    /// @param inputRange The input range\\n    /// @param epochHash The epoch hash\\n    /// @dev MUST fire a `ClaimSubmission` event.\\n    /// @dev MAY fire a `ClaimAcceptance` event, if the acceptance criteria is met.\\n    function submitClaim(\\n        address appContract,\\n        InputRange calldata inputRange,\\n        bytes32 epochHash\\n    ) external;\\n\\n    /// @notice Get the epoch hash for a certain application and input range.\\n    /// @param appContract The application contract address\\n    /// @param inputRange The input range\\n    /// @return epochHash The epoch hash\\n    /// @dev For claimed epochs, must return the epoch hash of the last accepted claim.\\n    /// @dev For unclaimed epochs, MUST either revert or return `bytes32(0)`.\\n    function getEpochHash(\\n        address appContract,\\n        InputRange calldata inputRange\\n    ) external view returns (bytes32 epochHash);\\n}\\n\",\"keccak256\":\"0xd2ea451e450f6b3b01bd77b95dbb00465d263cae9285a03c8ffd0d96c4d75dc1\",\"license\":\"Apache-2.0 (see LICENSE)\"},\"contracts/consensus/authority/Authority.sol\":{\"content\":\"// (c) Cartesi and individual authors (see AUTHORS)\\n// SPDX-License-Identifier: Apache-2.0 (see LICENSE)\\n\\npragma solidity ^0.8.8;\\n\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\nimport {IConsensus} from \\\"../IConsensus.sol\\\";\\nimport {AbstractConsensus} from \\\"../AbstractConsensus.sol\\\";\\nimport {InputRange} from \\\"../../common/InputRange.sol\\\";\\n\\n/// @notice A consensus contract controlled by a single address, the owner.\\n/// @dev This contract inherits from OpenZeppelin's `Ownable` contract.\\n///      For more information on `Ownable`, please consult OpenZeppelin's official documentation.\\ncontract Authority is AbstractConsensus, Ownable {\\n    /// @param initialOwner The initial contract owner\\n    constructor(address initialOwner) Ownable(initialOwner) {}\\n\\n    /// @notice Submit a claim.\\n    /// @param appContract The application contract address\\n    /// @param inputRange The input range\\n    /// @param epochHash The epoch hash\\n    /// @dev Fires a `ClaimSubmission` event and a `ClaimAcceptance` event.\\n    /// @dev Can only be called by the owner.\\n    function submitClaim(\\n        address appContract,\\n        InputRange calldata inputRange,\\n        bytes32 epochHash\\n    ) external override onlyOwner {\\n        emit ClaimSubmission(msg.sender, appContract, inputRange, epochHash);\\n        _acceptClaim(appContract, inputRange, epochHash);\\n    }\\n}\\n\",\"keccak256\":\"0xe74884532170247ebc0abfd564a8415cac18fafe4e2a1c9a851a369dd7ee4539\",\"license\":\"Apache-2.0 (see LICENSE)\"},\"contracts/consensus/authority/IAuthorityFactory.sol\":{\"content\":\"// (c) Cartesi and individual authors (see AUTHORS)\\n// SPDX-License-Identifier: Apache-2.0 (see LICENSE)\\n\\npragma solidity ^0.8.8;\\n\\nimport {Authority} from \\\"./Authority.sol\\\";\\n\\n/// @title Authority Factory interface\\ninterface IAuthorityFactory {\\n    // Events\\n\\n    /// @notice A new authority was deployed.\\n    /// @param authorityOwner The initial authority owner\\n    /// @param authority The authority\\n    /// @dev MUST be triggered on a successful call to `newAuthority`.\\n    event AuthorityCreated(address authorityOwner, Authority authority);\\n\\n    // Permissionless functions\\n\\n    /// @notice Deploy a new authority.\\n    /// @param authorityOwner The initial authority owner\\n    /// @return The authority\\n    /// @dev On success, MUST emit an `AuthorityCreated` event.\\n    function newAuthority(address authorityOwner) external returns (Authority);\\n\\n    /// @notice Deploy a new authority deterministically.\\n    /// @param authorityOwner The initial authority owner\\n    /// @param salt The salt used to deterministically generate the authority address\\n    /// @return The authority\\n    /// @dev On success, MUST emit an `AuthorityCreated` event.\\n    function newAuthority(\\n        address authorityOwner,\\n        bytes32 salt\\n    ) external returns (Authority);\\n\\n    /// @notice Calculate the address of an authority to be deployed deterministically.\\n    /// @param authorityOwner The initial authority owner\\n    /// @param salt The salt used to deterministically generate the authority address\\n    /// @return The deterministic authority address\\n    /// @dev Beware that only the `newAuthority` function with the `salt` parameter\\n    ///      is able to deterministically deploy an authority.\\n    function calculateAuthorityAddress(\\n        address authorityOwner,\\n        bytes32 salt\\n    ) external view returns (address);\\n}\\n\",\"keccak256\":\"0xb25511358cbebf34bbd3c6e518d55d0235bff4d25de414d96ce3468c7bf7d05a\",\"license\":\"Apache-2.0 (see LICENSE)\"},\"contracts/dapp/Application.sol\":{\"content\":\"// (c) Cartesi and individual authors (see AUTHORS)\\n// SPDX-License-Identifier: Apache-2.0 (see LICENSE)\\n\\npragma solidity ^0.8.8;\\n\\nimport {IApplication} from \\\"./IApplication.sol\\\";\\nimport {IConsensus} from \\\"../consensus/IConsensus.sol\\\";\\nimport {IInputBox} from \\\"../inputs/IInputBox.sol\\\";\\nimport {IPortal} from \\\"../portals/IPortal.sol\\\";\\nimport {LibOutputValidityProof} from \\\"../library/LibOutputValidityProof.sol\\\";\\nimport {OutputValidityProof} from \\\"../common/OutputValidityProof.sol\\\";\\nimport {Outputs} from \\\"../common/Outputs.sol\\\";\\nimport {InputRange} from \\\"../common/InputRange.sol\\\";\\nimport {LibInputRange} from \\\"../library/LibInputRange.sol\\\";\\nimport {LibAddress} from \\\"../library/LibAddress.sol\\\";\\n\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport {ERC721Holder} from \\\"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\\\";\\nimport {ERC1155Holder} from \\\"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\\\";\\nimport {ReentrancyGuard} from \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport {IERC721Receiver} from \\\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\\";\\nimport {IERC165} from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\nimport {BitMaps} from \\\"@openzeppelin/contracts/utils/structs/BitMaps.sol\\\";\\n\\ncontract Application is\\n    IApplication,\\n    Ownable,\\n    ERC721Holder,\\n    ERC1155Holder,\\n    ReentrancyGuard\\n{\\n    using BitMaps for BitMaps.BitMap;\\n    using LibAddress for address;\\n    using LibOutputValidityProof for OutputValidityProof;\\n    using LibInputRange for InputRange;\\n\\n    /// @notice The initial machine state hash.\\n    /// @dev See the `getTemplateHash` function.\\n    bytes32 internal immutable _templateHash;\\n\\n    /// @notice Keeps track of which outputs have been executed.\\n    /// @dev See the `wasOutputExecuted` function.\\n    mapping(uint256 => BitMaps.BitMap) internal _executed;\\n\\n    /// @notice The current consensus contract.\\n    /// @dev See the `getConsensus` and `migrateToConsensus` functions.\\n    IConsensus internal _consensus;\\n\\n    /// @notice The input box contract.\\n    /// @dev See the `getInputBox` function.\\n    IInputBox internal immutable _inputBox;\\n\\n    /// @notice The portals supported by the application.\\n    /// @dev See the `getPortals` function.\\n    IPortal[] internal _portals;\\n\\n    /// @notice Creates an `Application` contract.\\n    /// @param consensus The initial consensus contract\\n    /// @param inputBox The input box contract\\n    /// @param portals The portals supported by the application\\n    /// @param initialOwner The initial application owner\\n    /// @param templateHash The initial machine state hash\\n    constructor(\\n        IConsensus consensus,\\n        IInputBox inputBox,\\n        IPortal[] memory portals,\\n        address initialOwner,\\n        bytes32 templateHash\\n    ) Ownable(initialOwner) {\\n        _templateHash = templateHash;\\n        _consensus = consensus;\\n        _inputBox = inputBox;\\n        for (uint256 i; i < portals.length; ++i) {\\n            _portals.push(portals[i]);\\n        }\\n    }\\n\\n    /// @notice Accept Ether transfers.\\n    /// @dev If you wish to transfer Ether to an application while informing\\n    ///      the backend of it, then please do so through the Ether portal contract.\\n    receive() external payable {}\\n\\n    function executeOutput(\\n        bytes calldata output,\\n        OutputValidityProof calldata proof\\n    ) external override nonReentrant {\\n        validateOutput(output, proof);\\n\\n        uint256 inputIndex = proof.calculateInputIndex();\\n        uint64 outputIndexWithinInput = proof.outputIndexWithinInput;\\n\\n        BitMaps.BitMap storage bitmap = _executed[outputIndexWithinInput];\\n\\n        if (output.length < 4) {\\n            revert OutputNotExecutable(output);\\n        }\\n\\n        bytes4 selector = bytes4(output[:4]);\\n        bytes calldata arguments = output[4:];\\n\\n        if (selector == Outputs.Voucher.selector) {\\n            if (bitmap.get(inputIndex)) {\\n                revert OutputNotReexecutable(output);\\n            }\\n            _executeVoucher(arguments);\\n        } else if (selector == Outputs.DelegateCallVoucher.selector) {\\n            if (bitmap.get(inputIndex)) {\\n                revert OutputNotReexecutable(output);\\n            }\\n            _executeDelegateCallVoucher(arguments);\\n        } else {\\n            revert OutputNotExecutable(output);\\n        }\\n\\n        bitmap.set(inputIndex);\\n        emit OutputExecuted(uint64(inputIndex), outputIndexWithinInput, output);\\n    }\\n\\n    function migrateToConsensus(\\n        IConsensus newConsensus\\n    ) external override onlyOwner {\\n        _consensus = newConsensus;\\n        emit NewConsensus(newConsensus);\\n    }\\n\\n    function wasOutputExecuted(\\n        uint256 inputIndex,\\n        uint256 outputIndexWithinInput\\n    ) external view override returns (bool) {\\n        return _executed[outputIndexWithinInput].get(inputIndex);\\n    }\\n\\n    function validateOutput(\\n        bytes calldata output,\\n        OutputValidityProof calldata proof\\n    ) public view override {\\n        uint256 inputIndex = proof.calculateInputIndex();\\n\\n        if (!proof.inputRange.contains(inputIndex)) {\\n            revert InputIndexOutOfRange(inputIndex, proof.inputRange);\\n        }\\n\\n        bytes32 outputHash = keccak256(output);\\n\\n        if (!proof.isOutputHashesRootHashValid(outputHash)) {\\n            revert IncorrectOutputHashesRootHash();\\n        }\\n\\n        if (!proof.isOutputsEpochRootHashValid()) {\\n            revert IncorrectOutputsEpochRootHash();\\n        }\\n\\n        bytes32 epochHash = _getEpochHash(proof.inputRange);\\n\\n        if (!proof.isEpochHashValid(epochHash)) {\\n            revert IncorrectEpochHash();\\n        }\\n    }\\n\\n    function getTemplateHash() external view override returns (bytes32) {\\n        return _templateHash;\\n    }\\n\\n    function getConsensus() external view override returns (IConsensus) {\\n        return _consensus;\\n    }\\n\\n    function getInputBox() external view override returns (IInputBox) {\\n        return _inputBox;\\n    }\\n\\n    function getPortals() external view override returns (IPortal[] memory) {\\n        return _portals;\\n    }\\n\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view virtual override(ERC1155Holder, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IApplication).interfaceId ||\\n            interfaceId == type(IERC721Receiver).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /// @notice Get the epoch hash regarding an input range from the current consensus.\\n    /// @param inputRange The input range\\n    /// @return The epoch hash\\n    function _getEpochHash(\\n        InputRange calldata inputRange\\n    ) internal view returns (bytes32) {\\n        return _consensus.getEpochHash(address(this), inputRange);\\n    }\\n\\n    /// @notice Executes a voucher\\n    /// @param arguments ABI-encoded arguments\\n    function _executeVoucher(bytes calldata arguments) internal {\\n        address destination;\\n        uint256 value;\\n        bytes memory payload;\\n\\n        (destination, value, payload) = abi.decode(\\n            arguments,\\n            (address, uint256, bytes)\\n        );\\n\\n        destination.safeCall(value, payload);\\n    }\\n\\n    /// @notice Executes a delegatecall voucher\\n    /// @param arguments ABI-encoded arguments\\n    function _executeDelegateCallVoucher(bytes calldata arguments) internal {\\n        address destination;\\n        bytes memory payload;\\n\\n        (destination, payload) = abi.decode(arguments, (address, bytes));\\n\\n        destination.safeDelegateCall(payload);\\n    }\\n}\\n\",\"keccak256\":\"0x5119ba0344182acea4f1a5ce91c7386be17a48e4b2c9881f5a708a29357cc660\",\"license\":\"Apache-2.0 (see LICENSE)\"},\"contracts/dapp/IApplication.sol\":{\"content\":\"// (c) Cartesi and individual authors (see AUTHORS)\\n// SPDX-License-Identifier: Apache-2.0 (see LICENSE)\\n\\npragma solidity ^0.8.8;\\n\\nimport {IERC1155Receiver} from \\\"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\\\";\\nimport {IERC721Receiver} from \\\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\\";\\n\\nimport {IConsensus} from \\\"../consensus/IConsensus.sol\\\";\\nimport {IInputBox} from \\\"../inputs/IInputBox.sol\\\";\\nimport {IPortal} from \\\"../portals/IPortal.sol\\\";\\nimport {OutputValidityProof} from \\\"../common/OutputValidityProof.sol\\\";\\nimport {InputRange} from \\\"../common/InputRange.sol\\\";\\n\\n/// @notice The base layer incarnation of an application running on the execution layer.\\n/// @notice The state of the application advances through inputs sent to an `IInputBox` contract (see the `getInputBox` function).\\n/// @notice These inputs can be sent either directly, or indirectly through portals (see the `getPortals` function).\\n/// @notice Reader nodes can retrieve inputs sent to the `IInputBox` contract through events, and feed them into the machine.\\n/// @notice Validator nodes can also submit claims to the `IConsensus` contract (see the `getConsensus` function).\\n/// @notice Once accepted, claims can be used to validate outputs generated by the machine.\\n/// @notice Some outputs are executable, which means they can have on-chain side effects.\\n/// @notice Every application is subscribed to some consensus, and may be governed by some owner.\\n/// The consensus has the power to accept claims, which, in turn, are used to validate outputs.\\n/// Meanwhile, the owner can replace the consensus at any time.\\n/// Therefore, the users of an application must trust both the consensus and the application owner.\\n/// @notice There are several ownership models to choose from:\\n/// - no owner (address zero)\\n/// - individual signer (externally-owned account)\\n/// - multiple signers (multi-sig)\\n/// - DAO (decentralized autonomous organization)\\n/// - self-owned application (off-chain governance logic)\\n/// @notice See `IConsensus` for examples of consensus models.\\ninterface IApplication is IERC721Receiver, IERC1155Receiver {\\n    // Events\\n\\n    /// @notice MUST trigger when a new consensus is chosen.\\n    /// @param newConsensus The new consensus\\n    event NewConsensus(IConsensus newConsensus);\\n\\n    /// @notice MUST trigger when an output is executed.\\n    /// @param inputIndex The index of the input that emitted the output\\n    /// @param outputIndexWithinInput The index of the output amongst all outputs emitted by the input\\n    /// @param output The output\\n    event OutputExecuted(\\n        uint64 inputIndex,\\n        uint64 outputIndexWithinInput,\\n        bytes output\\n    );\\n\\n    // Errors\\n\\n    /// @notice Could not validate an output because the input\\n    /// that generated it is outside the input range of the epoch.\\n    /// @param inputIndex The input index\\n    /// @param inputRange The input range\\n    error InputIndexOutOfRange(uint256 inputIndex, InputRange inputRange);\\n\\n    /// @notice Could not execute an output, because the application contract doesn't know how to.\\n    /// @param output The output\\n    error OutputNotExecutable(bytes output);\\n\\n    /// @notice Could not execute an output, because it was already executed.\\n    /// @param output The output\\n    error OutputNotReexecutable(bytes output);\\n\\n    /// @notice Raised when some `OutputValidityProof` variables does not match\\n    ///         the presented finalized epoch.\\n    error IncorrectEpochHash();\\n\\n    /// @notice Raised when `OutputValidityProof` metadata memory range is NOT\\n    ///         contained in epoch's output memory range.\\n    error IncorrectOutputsEpochRootHash();\\n\\n    /// @notice Raised when Merkle root of output hash is NOT contained\\n    ///         in the output metadata array memory range.\\n    error IncorrectOutputHashesRootHash();\\n\\n    // Permissioned functions\\n\\n    /// @notice Migrate the application to a new consensus.\\n    /// @param newConsensus The new consensus\\n    /// @dev Can only be called by the application owner.\\n    function migrateToConsensus(IConsensus newConsensus) external;\\n\\n    // Permissionless functions\\n\\n    /// @notice Execute an output.\\n    /// @param output The output\\n    /// @param proof The proof used to validate the output against\\n    ///              a claim submitted by the current consensus contract\\n    /// @dev On a successful execution, emits a `OutputExecuted` event.\\n    /// @dev May raise any of the errors raised by `validateOutput`,\\n    /// as well as `OutputNotExecutable` and `OutputNotReexecutable`.\\n    function executeOutput(\\n        bytes calldata output,\\n        OutputValidityProof calldata proof\\n    ) external;\\n\\n    /// @notice Check whether an output has been executed.\\n    /// @param inputIndex The index of the input in the input box\\n    /// @param outputIndexWithinInput The index of output emitted by the input\\n    /// @return Whether the output has been executed before\\n    function wasOutputExecuted(\\n        uint256 inputIndex,\\n        uint256 outputIndexWithinInput\\n    ) external view returns (bool);\\n\\n    /// @notice Validate an output.\\n    /// @param output The output\\n    /// @param proof The proof used to validate the output against\\n    ///              a claim submitted by the current consensus contract\\n    /// @dev May raise `InputIndexOutOfRange`, `IncorrectEpochHash`,\\n    /// `IncorrectOutputsEpochRootHash`, or `IncorrectOutputHashesRootHash`.\\n    function validateOutput(\\n        bytes calldata output,\\n        OutputValidityProof calldata proof\\n    ) external view;\\n\\n    /// @notice Get the application's template hash.\\n    /// @return The application's template hash\\n    function getTemplateHash() external view returns (bytes32);\\n\\n    /// @notice Get the current consensus.\\n    /// @return The current consensus\\n    function getConsensus() external view returns (IConsensus);\\n\\n    /// @notice Get the input box that the application is listening to.\\n    /// @return The input box\\n    function getInputBox() external view returns (IInputBox);\\n\\n    /// @notice Get the portals that the application expects inputs from.\\n    /// @return The portals.\\n    function getPortals() external view returns (IPortal[] memory);\\n}\\n\",\"keccak256\":\"0xb7f77e632c14935998e986276cbea53e9a52bc576aae51cbc8c51cedcbafc6bc\",\"license\":\"Apache-2.0 (see LICENSE)\"},\"contracts/dapp/IApplicationFactory.sol\":{\"content\":\"// (c) Cartesi and individual authors (see AUTHORS)\\n// SPDX-License-Identifier: Apache-2.0 (see LICENSE)\\n\\npragma solidity ^0.8.8;\\n\\nimport {Application} from \\\"./Application.sol\\\";\\nimport {IConsensus} from \\\"../consensus/IConsensus.sol\\\";\\nimport {IInputBox} from \\\"../inputs/IInputBox.sol\\\";\\nimport {IPortal} from \\\"../portals/IPortal.sol\\\";\\n\\n/// @title Application Factory interface\\ninterface IApplicationFactory {\\n    // Events\\n\\n    /// @notice A new application was deployed.\\n    /// @param consensus The initial consensus contract\\n    /// @param inputBox The input box contract\\n    /// @param portals The portals supported by the application\\n    /// @param appOwner The initial application owner\\n    /// @param templateHash The initial machine state hash\\n    /// @param appContract The application contract\\n    /// @dev MUST be triggered on a successful call to `newApplication`.\\n    event ApplicationCreated(\\n        IConsensus indexed consensus,\\n        IInputBox inputBox,\\n        IPortal[] portals,\\n        address appOwner,\\n        bytes32 templateHash,\\n        Application appContract\\n    );\\n\\n    // Permissionless functions\\n\\n    /// @notice Deploy a new application.\\n    /// @param consensus The initial consensus contract\\n    /// @param inputBox The input box contract\\n    /// @param portals The portals supported by the application\\n    /// @param appOwner The initial application owner\\n    /// @param templateHash The initial machine state hash\\n    /// @return The application\\n    /// @dev On success, MUST emit an `ApplicationCreated` event.\\n    function newApplication(\\n        IConsensus consensus,\\n        IInputBox inputBox,\\n        IPortal[] calldata portals,\\n        address appOwner,\\n        bytes32 templateHash\\n    ) external returns (Application);\\n\\n    /// @notice Deploy a new application deterministically.\\n    /// @param consensus The initial consensus contract\\n    /// @param inputBox The input box contract\\n    /// @param portals The portals supported by the application\\n    /// @param appOwner The initial application owner\\n    /// @param templateHash The initial machine state hash\\n    /// @param salt The salt used to deterministically generate the application contract address\\n    /// @return The application\\n    /// @dev On success, MUST emit an `ApplicationCreated` event.\\n    function newApplication(\\n        IConsensus consensus,\\n        IInputBox inputBox,\\n        IPortal[] calldata portals,\\n        address appOwner,\\n        bytes32 templateHash,\\n        bytes32 salt\\n    ) external returns (Application);\\n\\n    /// @notice Calculate the address of an application contract to be deployed deterministically.\\n    /// @param consensus The initial consensus contract\\n    /// @param inputBox The input box contract\\n    /// @param portals The portals supported by the application\\n    /// @param appOwner The initial application owner\\n    /// @param templateHash The initial machine state hash\\n    /// @param salt The salt used to deterministically generate the application contract address\\n    /// @return The deterministic application contract address\\n    /// @dev Beware that only the `newApplication` function with the `salt` parameter\\n    ///      is able to deterministically deploy an application.\\n    function calculateApplicationAddress(\\n        IConsensus consensus,\\n        IInputBox inputBox,\\n        IPortal[] calldata portals,\\n        address appOwner,\\n        bytes32 templateHash,\\n        bytes32 salt\\n    ) external view returns (address);\\n}\\n\",\"keccak256\":\"0xc8124036aad5321f0c30692196984061f55c82599a8da5c83f10bcfa64403817\",\"license\":\"Apache-2.0 (see LICENSE)\"},\"contracts/dapp/ISelfHostedApplicationFactory.sol\":{\"content\":\"// (c) Cartesi and individual authors (see AUTHORS)\\n// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity ^0.8.8;\\n\\nimport {Authority} from \\\"../consensus/authority/Authority.sol\\\";\\nimport {IAuthorityFactory} from \\\"../consensus/authority/IAuthorityFactory.sol\\\";\\nimport {Application} from \\\"./Application.sol\\\";\\nimport {IApplicationFactory} from \\\"./IApplicationFactory.sol\\\";\\nimport {IInputBox} from \\\"../inputs/IInputBox.sol\\\";\\nimport {IPortal} from \\\"../portals/IPortal.sol\\\";\\n\\n/// @title Self-hosted Application Factory interface\\ninterface ISelfHostedApplicationFactory {\\n    /// @notice Get the factory used to deploy `Authority` contracts\\n    /// @return The authority factory\\n    function getAuthorityFactory() external view returns (IAuthorityFactory);\\n\\n    /// @notice Get the factory used to deploy `Application` contracts\\n    /// @return The application factory\\n    function getApplicationFactory()\\n        external\\n        view\\n        returns (IApplicationFactory);\\n\\n    /// @notice Deploy new application and authority contracts deterministically.\\n    /// @param authorityOwner The initial authority owner\\n    /// @param inputBox The input box contract\\n    /// @param portals The portals supported by the application\\n    /// @param appOwner The initial Application owner\\n    /// @param templateHash The initial machine state hash\\n    /// @param salt The salt used to deterministically generate the addresses\\n    /// @return The application contract\\n    /// @return The authority contract\\n    function deployContracts(\\n        address authorityOwner,\\n        IInputBox inputBox,\\n        IPortal[] calldata portals,\\n        address appOwner,\\n        bytes32 templateHash,\\n        bytes32 salt\\n    ) external returns (Application, Authority);\\n\\n    /// @notice Calculate the addresses of the application and authority contracts\\n    /// to be deployed deterministically.\\n    /// @param authorityOwner The initial authority owner\\n    /// @param inputBox The input box contract\\n    /// @param portals The portals supported by the application\\n    /// @param appOwner The initial Application owner\\n    /// @param templateHash The initial machine state hash\\n    /// @param salt The salt used to deterministically generate the addresses\\n    /// @return The application address\\n    /// @return The authority address\\n    function calculateAddresses(\\n        address authorityOwner,\\n        IInputBox inputBox,\\n        IPortal[] calldata portals,\\n        address appOwner,\\n        bytes32 templateHash,\\n        bytes32 salt\\n    ) external view returns (address, address);\\n}\\n\",\"keccak256\":\"0x3b75e98ec240be8969c0b1330f6a04ccd7d65dfac299a24155180bf28fc06336\",\"license\":\"Apache-2.0\"},\"contracts/dapp/SelfHostedApplicationFactory.sol\":{\"content\":\"// (c) Cartesi and individual authors (see AUTHORS)\\n// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity ^0.8.8;\\n\\nimport {IConsensus} from \\\"../consensus/IConsensus.sol\\\";\\nimport {Authority} from \\\"../consensus/authority/Authority.sol\\\";\\nimport {IAuthorityFactory} from \\\"../consensus/authority/IAuthorityFactory.sol\\\";\\nimport {Application} from \\\"./Application.sol\\\";\\nimport {IApplicationFactory} from \\\"./IApplicationFactory.sol\\\";\\nimport {ISelfHostedApplicationFactory} from \\\"./ISelfHostedApplicationFactory.sol\\\";\\nimport {IInputBox} from \\\"../inputs/IInputBox.sol\\\";\\nimport {IPortal} from \\\"../portals/IPortal.sol\\\";\\n\\n/// @title Self-hosted Application Factory\\n/// @notice Allows anyone to reliably deploy a new Authority contract,\\n/// along with an Application contract already linked to it.\\ncontract SelfHostedApplicationFactory is ISelfHostedApplicationFactory {\\n    IAuthorityFactory immutable _authorityFactory;\\n    IApplicationFactory immutable _applicationFactory;\\n\\n    /// @param authorityFactory The authority factory\\n    /// @param applicationFactory The application factory\\n    constructor(\\n        IAuthorityFactory authorityFactory,\\n        IApplicationFactory applicationFactory\\n    ) {\\n        _authorityFactory = authorityFactory;\\n        _applicationFactory = applicationFactory;\\n    }\\n\\n    function getAuthorityFactory()\\n        external\\n        view\\n        override\\n        returns (IAuthorityFactory)\\n    {\\n        return _authorityFactory;\\n    }\\n\\n    function getApplicationFactory()\\n        external\\n        view\\n        override\\n        returns (IApplicationFactory)\\n    {\\n        return _applicationFactory;\\n    }\\n\\n    function deployContracts(\\n        address authorityOwner,\\n        IInputBox inputBox,\\n        IPortal[] memory portals,\\n        address appOwner,\\n        bytes32 templateHash,\\n        bytes32 salt\\n    ) external returns (Application application, Authority authority) {\\n        authority = _authorityFactory.newAuthority(authorityOwner, salt);\\n\\n        application = _applicationFactory.newApplication(\\n            authority,\\n            inputBox,\\n            portals,\\n            appOwner,\\n            templateHash,\\n            salt\\n        );\\n    }\\n\\n    function calculateAddresses(\\n        address authorityOwner,\\n        IInputBox inputBox,\\n        IPortal[] memory portals,\\n        address appOwner,\\n        bytes32 templateHash,\\n        bytes32 salt\\n    ) external view returns (address application, address authority) {\\n        authority = _authorityFactory.calculateAuthorityAddress(\\n            authorityOwner,\\n            salt\\n        );\\n\\n        application = _applicationFactory.calculateApplicationAddress(\\n            IConsensus(authority),\\n            inputBox,\\n            portals,\\n            appOwner,\\n            templateHash,\\n            salt\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0xf52c824ffab63f5cacf299c133b2c38298814ace781ce13e04598bca2bb8036d\",\"license\":\"Apache-2.0\"},\"contracts/inputs/IInputBox.sol\":{\"content\":\"// (c) Cartesi and individual authors (see AUTHORS)\\n// SPDX-License-Identifier: Apache-2.0 (see LICENSE)\\n\\npragma solidity ^0.8.8;\\n\\n/// @notice Provides data availability of inputs for applications.\\n/// @notice Each application has its own append-only list of inputs.\\n/// @notice Off-chain, inputs can be retrieved via events.\\n/// @notice On-chain, only the input hashes are stored.\\n/// @notice See `LibInput` for more details on how such hashes are computed.\\ninterface IInputBox {\\n    /// @notice MUST trigger when an input is added.\\n    /// @param appContract The application contract address\\n    /// @param index The input index\\n    /// @param input The input blob\\n    event InputAdded(\\n        address indexed appContract,\\n        uint256 indexed index,\\n        bytes input\\n    );\\n\\n    /// @notice Input is too large.\\n    /// @param appContract The application contract address\\n    /// @param inputLength The input length\\n    /// @param maxInputLength The maximum input length\\n    error InputTooLarge(\\n        address appContract,\\n        uint256 inputLength,\\n        uint256 maxInputLength\\n    );\\n\\n    /// @notice Send an input to an application.\\n    /// @param appContract The application contract address\\n    /// @param payload The input payload\\n    /// @return The hash of the input blob\\n    /// @dev MUST fire an `InputAdded` event.\\n    function addInput(\\n        address appContract,\\n        bytes calldata payload\\n    ) external returns (bytes32);\\n\\n    /// @notice Get the number of inputs sent to an application.\\n    /// @param appContract The application contract address\\n    function getNumberOfInputs(\\n        address appContract\\n    ) external view returns (uint256);\\n\\n    /// @notice Get the hash of an input in an application's input box.\\n    /// @param appContract The application contract address\\n    /// @param index The input index\\n    /// @dev The provided index must be valid.\\n    function getInputHash(\\n        address appContract,\\n        uint256 index\\n    ) external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0xae7730cd7ab2b31a86d7c4933215853ea6c0b1b4dc60d4ec24e5cfc2ec005fe3\",\"license\":\"Apache-2.0 (see LICENSE)\"},\"contracts/library/LibAddress.sol\":{\"content\":\"// (c) Cartesi and individual authors (see AUTHORS)\\n// SPDX-License-Identifier: Apache-2.0 (see LICENSE)\\n\\npragma solidity ^0.8.8;\\n\\nimport {LibError} from \\\"../library/LibError.sol\\\";\\n\\nlibrary LibAddress {\\n    using LibError for bytes;\\n\\n    /// @notice Perform a low level call and raise error if failed\\n    /// @param destination The address that will be called\\n    /// @param value The amount of Wei to be transferred through the call\\n    /// @param payload The payload, which\\u2014in the case of Solidity\\n    /// contracts\\u2014encodes a function call\\n    function safeCall(\\n        address destination,\\n        uint256 value,\\n        bytes memory payload\\n    ) internal {\\n        bool success;\\n        bytes memory returndata;\\n\\n        (success, returndata) = destination.call{value: value}(payload);\\n\\n        if (!success) {\\n            returndata.raise();\\n        }\\n    }\\n\\n    /// @notice Perform a delegate call and raise error if failed\\n    /// @param destination The address that will be called\\n    /// @param payload The payload, which\\u2014in the case of Solidity\\n    /// libraries\\u2014encodes a function call\\n    function safeDelegateCall(\\n        address destination,\\n        bytes memory payload\\n    ) internal {\\n        bool success;\\n        bytes memory returndata;\\n\\n        (success, returndata) = destination.delegatecall(payload);\\n\\n        if (!success) {\\n            returndata.raise();\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xcae26d227ecb61fe953e6a5937037529b02fd929f6857151661121d6d233c0ac\",\"license\":\"Apache-2.0 (see LICENSE)\"},\"contracts/library/LibError.sol\":{\"content\":\"// (c) Cartesi and individual authors (see AUTHORS)\\n// SPDX-License-Identifier: Apache-2.0 (see LICENSE)\\n\\npragma solidity ^0.8.8;\\n\\nlibrary LibError {\\n    /// @notice Raise error data\\n    /// @param errordata Data returned by failed low-level call\\n    function raise(bytes memory errordata) internal pure {\\n        if (errordata.length == 0) {\\n            revert();\\n        } else {\\n            assembly {\\n                revert(add(32, errordata), mload(errordata))\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x3d5f9497f40e172fe1a0b9e2635cd4b14c4c3d16bcfd851db034273573aae37d\",\"license\":\"Apache-2.0 (see LICENSE)\"},\"contracts/library/LibInputRange.sol\":{\"content\":\"// (c) Cartesi and individual authors (see AUTHORS)\\n// SPDX-License-Identifier: Apache-2.0 (see LICENSE)\\n\\npragma solidity ^0.8.8;\\n\\nimport {InputRange} from \\\"../common/InputRange.sol\\\";\\n\\nlibrary LibInputRange {\\n    /// @notice Check if an input range contains an input.\\n    /// @param r The input range\\n    /// @param inputIndex The input index\\n    /// @return Whether the input range contains the input.\\n    function contains(\\n        InputRange calldata r,\\n        uint256 inputIndex\\n    ) internal pure returns (bool) {\\n        return r.firstIndex <= inputIndex && inputIndex <= r.lastIndex;\\n    }\\n}\\n\",\"keccak256\":\"0x30e95c1eb8b8f45bf4bc02c26e2b69a949025fa1bb34cb804137d7e2d229aa78\",\"license\":\"Apache-2.0 (see LICENSE)\"},\"contracts/library/LibMerkle32.sol\":{\"content\":\"// (c) Cartesi and individual authors (see AUTHORS)\\n// SPDX-License-Identifier: Apache-2.0 (see LICENSE)\\n\\npragma solidity ^0.8.22;\\n\\n/// @title Merkle library for trees of 32-byte leaves\\n/// @notice This library is meant for creating and verifying Merkle proofs.\\n/// @notice Each Merkle tree is assumed to have `2^height` leaves.\\n/// @notice Nodes are concatenated pairwise and hashed with `keccak256`.\\n/// @notice Siblings are in bottom-up order, from leaf to root.\\nlibrary LibMerkle32 {\\n    using LibMerkle32 for bytes32[];\\n\\n    /// @notice Compute the root of a Merkle tree from its leaves.\\n    /// @param leaves The left-most leaves of the Merkle tree\\n    /// @param height The height of the Merkle tree\\n    /// @return The root hash of the Merkle tree\\n    /// @dev Raises an error if more than `2^height` leaves are provided.\\n    function merkleRoot(\\n        bytes32[] memory leaves,\\n        uint256 height\\n    ) internal pure returns (bytes32) {\\n        bytes32 defaultNode;\\n        for (uint256 i; i < height; ++i) {\\n            leaves = leaves.parentLevel(defaultNode);\\n            defaultNode = parent(defaultNode, defaultNode);\\n        }\\n        require(leaves.length <= 1, \\\"LibMerkle32: too many leaves\\\");\\n        return leaves.at(0, defaultNode);\\n    }\\n\\n    /// @notice Compute the siblings of the ancestors of a leaf in a Merkle tree.\\n    /// @param leaves The left-most leaves of the Merkle tree\\n    /// @param index The index of the leaf\\n    /// @param height The height of the Merkle tree\\n    /// @return The siblings of the ancestors of the leaf in bottom-up order\\n    /// @dev Raises an error if the provided index is out of bounds.\\n    /// @dev Raises an error if more than `2^height` leaves are provided.\\n    function siblings(\\n        bytes32[] memory leaves,\\n        uint256 index,\\n        uint256 height\\n    ) internal pure returns (bytes32[] memory) {\\n        bytes32[] memory sibs = new bytes32[](height);\\n        bytes32 defaultNode;\\n        for (uint256 i; i < height; ++i) {\\n            sibs[i] = leaves.at(index ^ 1, defaultNode);\\n            leaves = leaves.parentLevel(defaultNode);\\n            defaultNode = parent(defaultNode, defaultNode);\\n            index >>= 1;\\n        }\\n        require(index == 0, \\\"LibMerkle32: index out of bounds\\\");\\n        require(leaves.length <= 1, \\\"LibMerkle32: too many leaves\\\");\\n        return sibs;\\n    }\\n\\n    /// @notice Compute the root of a Merkle tree after replacing one of its leaves.\\n    /// @param sibs The siblings of the ancestors of the leaf in bottom-up order\\n    /// @param index The index of the leaf\\n    /// @param leaf The new leaf\\n    /// @return The root hash of the new Merkle tree\\n    /// @dev Raises an error if the provided index is out of bounds.\\n    function merkleRootAfterReplacement(\\n        bytes32[] calldata sibs,\\n        uint256 index,\\n        bytes32 leaf\\n    ) internal pure returns (bytes32) {\\n        uint256 height = sibs.length;\\n        for (uint256 i; i < height; ++i) {\\n            bytes32 sibling = sibs[i];\\n            if (index & 1 == 0) {\\n                leaf = parent(leaf, sibling);\\n            } else {\\n                leaf = parent(sibling, leaf);\\n            }\\n            index >>= 1;\\n        }\\n        require(index == 0, \\\"LibMerkle32: index out of bounds\\\");\\n        return leaf;\\n    }\\n\\n    /// @notice Compute the parent of two nodes.\\n    /// @param leftNode The left node\\n    /// @param rightNode The right node\\n    /// @return parentNode The parent node\\n    /// @dev Uses assembly for extra performance\\n    function parent(\\n        bytes32 leftNode,\\n        bytes32 rightNode\\n    ) internal pure returns (bytes32 parentNode) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, leftNode)\\n            mstore(0x20, rightNode)\\n            parentNode := keccak256(0x00, 0x40)\\n        }\\n    }\\n\\n    /// @notice Compute the parent level of an array of nodes.\\n    /// @param nodes The array of left-most nodes\\n    /// @param defaultNode The default node after the array\\n    /// @return The left-most nodes of the parent level\\n    /// @dev The default node of a parent level is\\n    /// the parent node of two default nodes.\\n    function parentLevel(\\n        bytes32[] memory nodes,\\n        bytes32 defaultNode\\n    ) internal pure returns (bytes32[] memory) {\\n        uint256 n = (nodes.length + 1) / 2; // ceil(#nodes / 2)\\n        bytes32[] memory level = new bytes32[](n);\\n        for (uint256 i; i < n; ++i) {\\n            bytes32 leftLeaf = nodes[2 * i];\\n            bytes32 rightLeaf = nodes.at(2 * i + 1, defaultNode);\\n            level[i] = parent(leftLeaf, rightLeaf);\\n        }\\n        return level;\\n    }\\n\\n    /// @notice Get the node at some index\\n    /// @param nodes The array of left-most nodes\\n    /// @param index The index of the node\\n    /// @param defaultNode The default node after the array\\n    function at(\\n        bytes32[] memory nodes,\\n        uint256 index,\\n        bytes32 defaultNode\\n    ) internal pure returns (bytes32) {\\n        if (index < nodes.length) {\\n            return nodes[index];\\n        } else {\\n            return defaultNode;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x47ec1967c131735784544d1e1610a4eca01d54198411184f5e16c8662c5b63e7\",\"license\":\"Apache-2.0 (see LICENSE)\"},\"contracts/library/LibOutputValidityProof.sol\":{\"content\":\"// (c) Cartesi and individual authors (see AUTHORS)\\n// SPDX-License-Identifier: Apache-2.0 (see LICENSE)\\n\\npragma solidity ^0.8.8;\\n\\nimport {CanonicalMachine} from \\\"../common/CanonicalMachine.sol\\\";\\nimport {Outputs} from \\\"../common/Outputs.sol\\\";\\nimport {OutputValidityProof} from \\\"../common/OutputValidityProof.sol\\\";\\n\\nimport {LibMerkle32} from \\\"./LibMerkle32.sol\\\";\\n\\nlibrary LibOutputValidityProof {\\n    using LibMerkle32 for bytes32[];\\n\\n    /// @notice Check if epoch hash is valid\\n    /// @param v The output validity proof\\n    /// @param epochHash The epoch hash\\n    function isEpochHashValid(\\n        OutputValidityProof calldata v,\\n        bytes32 epochHash\\n    ) internal pure returns (bool) {\\n        return\\n            epochHash ==\\n            keccak256(abi.encode(v.outputsEpochRootHash, v.machineStateHash));\\n    }\\n\\n    /// @notice Check if the outputs epoch root hash is valid\\n    /// @param v The output validity proof\\n    function isOutputsEpochRootHashValid(\\n        OutputValidityProof calldata v\\n    ) internal pure returns (bool) {\\n        bytes32[] calldata siblings = v.outputHashesInEpochSiblings;\\n        return\\n            (siblings.length == CanonicalMachine.LOG2_MAX_INPUTS_PER_EPOCH) &&\\n            (v.outputsEpochRootHash ==\\n                siblings.merkleRootAfterReplacement(\\n                    v.inputIndexWithinEpoch,\\n                    v.outputHashesRootHash\\n                ));\\n    }\\n\\n    /// @notice Check if the output hashes root hash is valid\\n    /// @param v The output validity proof\\n    /// @param outputHash The output hash\\n    function isOutputHashesRootHashValid(\\n        OutputValidityProof calldata v,\\n        bytes32 outputHash\\n    ) internal pure returns (bool) {\\n        bytes32[] calldata siblings = v.outputHashInOutputHashesSiblings;\\n        return\\n            (siblings.length == CanonicalMachine.LOG2_MAX_OUTPUTS_PER_INPUT) &&\\n            (v.outputHashesRootHash ==\\n                siblings.merkleRootAfterReplacement(\\n                    v.outputIndexWithinInput,\\n                    outputHash\\n                ));\\n    }\\n\\n    /// @notice Calculate the input index\\n    /// @param v The output validity proof\\n    /// @return The input index\\n    function calculateInputIndex(\\n        OutputValidityProof calldata v\\n    ) internal pure returns (uint256) {\\n        return uint256(v.inputRange.firstIndex) + v.inputIndexWithinEpoch;\\n    }\\n}\\n\",\"keccak256\":\"0x2719d93756e4477a7827c455a55f08066da64257a9570a867df3fbf2022217b8\",\"license\":\"Apache-2.0 (see LICENSE)\"},\"contracts/portals/IPortal.sol\":{\"content\":\"// (c) Cartesi and individual authors (see AUTHORS)\\n// SPDX-License-Identifier: Apache-2.0 (see LICENSE)\\n\\npragma solidity ^0.8.8;\\n\\nimport {IInputBox} from \\\"../inputs/IInputBox.sol\\\";\\nimport {IERC165} from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\n/// @title Portal interface\\ninterface IPortal is IERC165 {\\n    // Permissionless functions\\n\\n    /// @notice Get the input box used by this portal.\\n    /// @return The input box\\n    function getInputBox() external view returns (IInputBox);\\n}\\n\",\"keccak256\":\"0xbc364030939ea4a214e2f3673eaca1c500fcfd4929239a3b5d804ffc5687ed37\",\"license\":\"Apache-2.0 (see LICENSE)\"}},\"version\":1}",
  "bytecode": "0x60c060405234801561001057600080fd5b5060405161065138038061065183398101604081905261002f9161005e565b6001600160a01b039182166080521660a052610098565b6001600160a01b038116811461005b57600080fd5b50565b6000806040838503121561007157600080fd5b825161007c81610046565b602084015190925061008d81610046565b809150509250929050565b60805160a05161057a6100d76000396000818160c5015281816101ae01526102eb0152600081816053015281816101270152610267015261057a6000f3fe608060405234801561001057600080fd5b506004361061004c5760003560e01c806375689f8314610051578063c03db64f14610090578063e63d50ff146100c3578063ea60bcb9146100e9575b600080fd5b7f00000000000000000000000000000000000000000000000000000000000000005b6040516001600160a01b0390911681526020015b60405180910390f35b6100a361009e366004610385565b6100fc565b604080516001600160a01b03938416815292909116602083015201610087565b7f0000000000000000000000000000000000000000000000000000000000000000610073565b6100a36100f7366004610385565b61023d565b604051635a3f27d360e01b81526001600160a01b0387811660048301526024820183905260009182917f00000000000000000000000000000000000000000000000000000000000000001690635a3f27d3906044016020604051808303816000875af1158015610170573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101949190610494565b6040516303557d6760e01b81529091506001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016906303557d67906101ed9084908b908b908b908b908b906004016104fd565b6020604051808303816000875af115801561020c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102309190610494565b9150965096945050505050565b604051622715e160e21b81526001600160a01b0387811660048301526024820183905260009182917f00000000000000000000000000000000000000000000000000000000000000001690629c578490604401602060405180830381865afa1580156102ad573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102d19190610494565b60405163f63adead60e01b81529091506001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169063f63adead9061032a9084908b908b908b908b908b906004016104fd565b602060405180830381865afa15801561020c573d6000803e3d6000fd5b6001600160a01b038116811461035c57600080fd5b50565b803561036a81610347565b919050565b634e487b7160e01b600052604160045260246000fd5b60008060008060008060c0878903121561039e57600080fd5b86356103a981610347565b95506020878101356103ba81610347565b9550604088013567ffffffffffffffff808211156103d757600080fd5b818a0191508a601f8301126103eb57600080fd5b8135818111156103fd576103fd61036f565b8060051b604051601f19603f830116810181811085821117156104225761042261036f565b60405291825284820192508381018501918d83111561044057600080fd5b938501935b82851015610465576104568561035f565b84529385019392850192610445565b80995050505050505061047a6060880161035f565b92506080870135915060a087013590509295509295509295565b6000602082840312156104a657600080fd5b81516104b181610347565b9392505050565b60008151808452602080850194506020840160005b838110156104f25781516001600160a01b0316875295820195908201906001016104cd565b509495945050505050565b600060018060a01b038089168352808816602084015260c0604084015261052760c08401886104b8565b9516606083015250608081019290925260a090910152939250505056fea2646970667358221220e42a7dc01ef56a32cca5105f756721819ca0448d27d0e1cf6b071de6f3bfa42e64736f6c63430008170033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061004c5760003560e01c806375689f8314610051578063c03db64f14610090578063e63d50ff146100c3578063ea60bcb9146100e9575b600080fd5b7f00000000000000000000000000000000000000000000000000000000000000005b6040516001600160a01b0390911681526020015b60405180910390f35b6100a361009e366004610385565b6100fc565b604080516001600160a01b03938416815292909116602083015201610087565b7f0000000000000000000000000000000000000000000000000000000000000000610073565b6100a36100f7366004610385565b61023d565b604051635a3f27d360e01b81526001600160a01b0387811660048301526024820183905260009182917f00000000000000000000000000000000000000000000000000000000000000001690635a3f27d3906044016020604051808303816000875af1158015610170573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101949190610494565b6040516303557d6760e01b81529091506001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016906303557d67906101ed9084908b908b908b908b908b906004016104fd565b6020604051808303816000875af115801561020c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102309190610494565b9150965096945050505050565b604051622715e160e21b81526001600160a01b0387811660048301526024820183905260009182917f00000000000000000000000000000000000000000000000000000000000000001690629c578490604401602060405180830381865afa1580156102ad573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102d19190610494565b60405163f63adead60e01b81529091506001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169063f63adead9061032a9084908b908b908b908b908b906004016104fd565b602060405180830381865afa15801561020c573d6000803e3d6000fd5b6001600160a01b038116811461035c57600080fd5b50565b803561036a81610347565b919050565b634e487b7160e01b600052604160045260246000fd5b60008060008060008060c0878903121561039e57600080fd5b86356103a981610347565b95506020878101356103ba81610347565b9550604088013567ffffffffffffffff808211156103d757600080fd5b818a0191508a601f8301126103eb57600080fd5b8135818111156103fd576103fd61036f565b8060051b604051601f19603f830116810181811085821117156104225761042261036f565b60405291825284820192508381018501918d83111561044057600080fd5b938501935b82851015610465576104568561035f565b84529385019392850192610445565b80995050505050505061047a6060880161035f565b92506080870135915060a087013590509295509295509295565b6000602082840312156104a657600080fd5b81516104b181610347565b9392505050565b60008151808452602080850194506020840160005b838110156104f25781516001600160a01b0316875295820195908201906001016104cd565b509495945050505050565b600060018060a01b038089168352808816602084015260c0604084015261052760c08401886104b8565b9516606083015250608081019290925260a090910152939250505056fea2646970667358221220e42a7dc01ef56a32cca5105f756721819ca0448d27d0e1cf6b071de6f3bfa42e64736f6c63430008170033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "calculateAddresses(address,address,address[],address,bytes32,bytes32)": {
        "params": {
          "appOwner": "The initial Application owner",
          "authorityOwner": "The initial authority owner",
          "inputBox": "The input box contract",
          "portals": "The portals supported by the application",
          "salt": "The salt used to deterministically generate the addresses",
          "templateHash": "The initial machine state hash"
        },
        "returns": {
          "application": "The application address",
          "authority": "The authority address"
        }
      },
      "constructor": {
        "params": {
          "applicationFactory": "The application factory",
          "authorityFactory": "The authority factory"
        }
      },
      "deployContracts(address,address,address[],address,bytes32,bytes32)": {
        "params": {
          "appOwner": "The initial Application owner",
          "authorityOwner": "The initial authority owner",
          "inputBox": "The input box contract",
          "portals": "The portals supported by the application",
          "salt": "The salt used to deterministically generate the addresses",
          "templateHash": "The initial machine state hash"
        },
        "returns": {
          "application": "The application contract",
          "authority": "The authority contract"
        }
      },
      "getApplicationFactory()": {
        "returns": {
          "_0": "The application factory"
        }
      },
      "getAuthorityFactory()": {
        "returns": {
          "_0": "The authority factory"
        }
      }
    },
    "title": "Self-hosted Application Factory",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "calculateAddresses(address,address,address[],address,bytes32,bytes32)": {
        "notice": "Calculate the addresses of the application and authority contracts to be deployed deterministically."
      },
      "deployContracts(address,address,address[],address,bytes32,bytes32)": {
        "notice": "Deploy new application and authority contracts deterministically."
      },
      "getApplicationFactory()": {
        "notice": "Get the factory used to deploy `Application` contracts"
      },
      "getAuthorityFactory()": {
        "notice": "Get the factory used to deploy `Authority` contracts"
      }
    },
    "notice": "Allows anyone to reliably deploy a new Authority contract, along with an Application contract already linked to it.",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}